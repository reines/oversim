<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: PastryLeafSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>PastryLeafSet Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PastryLeafSet" --><!-- doxytag: inherits="PastryStateObject" -->
<p><a class="el" href="classPastryLeafSet.html" title="PastryLeafSet module.">PastryLeafSet</a> module.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PastryLeafSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPastryLeafSet.png" usemap="#PastryLeafSet_map" alt=""/>
  <map id="PastryLeafSet_map" name="PastryLeafSet_map">
<area href="classPastryStateObject.html" alt="PastryStateObject" shape="rect" coords="0,0,113,24"/>
</map>
</div>

<p><a href="classPastryLeafSet-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aa2c78d769e86e656409342e553c9af0a">initializeSet</a> (uint32_t <a class="el" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>, uint32_t <a class="el" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>, simtime_t <a class="el" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a>, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;<a class="el" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc">owner</a>, <a class="el" href="classBasePastry.html">BasePastry</a> *<a class="el" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f">overlay</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the leaf set.  <a href="#aa2c78d769e86e656409342e553c9af0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a8d3bbe87fe682fc513a83df7a0d69f57">getDestinationNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the final node according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme.  <a href="#a8d3bbe87fe682fc513a83df7a0d69f57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ae42c594976b0f7dbc1a24269b3cc6c89">findCloserNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, bool optimize=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to find a node numerically closer to a given key with the same shared prefix as the current node in the leaf set.  <a href="#ae42c594976b0f7dbc1a24269b3cc6c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a54cf1b5716243dc9ea4f840e3076c720">findCloserNodes</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, <a class="el" href="classBaseKeySortedVector.html">NodeVector</a> *nodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ad691bdd611ba773d5b7a0a90af491498">failedNode</a> (const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;failed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tells the leafset that a node has failed  <a href="#ad691bdd611ba773d5b7a0a90af491498"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aee63679544eb8ea21dbbf4d5dc7ef330">repair</a> (const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *prox)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">attempt to repair the leafset using a received REPAIR message  <a href="#aee63679544eb8ea21dbbf4d5dc7ef330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aa525adf4fc0334d812fbb70a50b78ca5">isClosestNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">checks if we are the closest node to key destination in the overlay  <a href="#aa525adf4fc0334d812fbb70a50b78ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a86d0046df97f4d54384d2a0b3936c53e">dumpToStateMessage</a> (<a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dump content of the set to a <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a>  <a href="#a86d0046df97f4d54384d2a0b3936c53e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a305d1f6be0b34ee3349b725a6039d0b9">dumpToStateMessage</a> (<a class="el" href="classPastryLeafsetMessage.html">PastryLeafsetMessage</a> *msg) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dump content of the set to a <a class="el" href="classPastryLeafsetMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryLeafsetMessage</a>  <a href="#a305d1f6be0b34ee3349b725a6039d0b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a76dca71b4a758f9aec046e1626b5a42e">getRandomNode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a random node from the leafset  <a href="#a76dca71b4a758f9aec046e1626b5a42e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a1e19ba86f8c54fdab06a8aed85a8c95f">mergeNode</a> (const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;node, simtime_t prox)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">merge a node into LeafSet  <a href="#a1e19ba86f8c54fdab06a8aed85a8c95f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aa6b310e05c4fd88e015092740665e98f">getPredecessor</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return predecessor node for visualizing  <a href="#aa6b310e05c4fd88e015092740665e98f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ab613105c42c31ecf5b4353a213036b63">getSuccessor</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return successor node for visualizing  <a href="#ab613105c42c31ecf5b4353a213036b63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ae13d5a42c50606e3cc0fbcd830429322">isValid</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if LeafSet knows at least one node to the left and to the right  <a href="#ae13d5a42c50606e3cc0fbcd830429322"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a529939c1a02749c1b18300404172c6ad">dumpToVector</a> (std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;affected) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">appends all leaf set entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining.  <a href="#a529939c1a02749c1b18300404172c6ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseKeySortedVector.html">NodeVector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a8e35d7891d1a32e48fce420555ff2b4d">createSiblingVector</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;key, int numSiblings) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPastryNewLeafsMessage.html">PastryNewLeafsMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a3d51346450731df0d955386d19f45f72">getNewLeafsMessage</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generates a newLeafs-message if LeafSet changed since last call to this method.  <a href="#a3d51346450731df0d955386d19f45f72"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a606dbf99943147de93fef16e9bc4bb1f">earlyInit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize watches etc.  <a href="#a606dbf99943147de93fef16e9bc4bb1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8">getBiggestNode</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the node with the biggest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty  <a href="#a5b83a6b8a5ef6ad328b88710ea1164b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a9b1713cff5c488d9eb918107dd735514">getBiggestKey</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the biggest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty  <a href="#a9b1713cff5c488d9eb918107dd735514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727">getSmallestNode</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the node with the smallest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty  <a href="#a95c6d44e09bd76f79a11f097bf05e727"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a7eae5839ee4ef18bf37984cbc99ce11e">getSmallestKey</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the smallest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty  <a href="#a7eae5839ee4ef18bf37984cbc99ce11e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aafdca32c4ad0049c6b260ae61cc5a8f5">isLeft</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test if a given key should be placed on the left or on the right side of the leaf set  <a href="#aafdca32c4ad0049c6b260ae61cc5a8f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b">insertLeaf</a> (std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator &amp;it, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">insert a leaf at a given position  <a href="#ac563e858547e96db005896f8d822d84b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aec4b33e2ef0b6bcf7e9803102f5bd174">balanceLeafSet</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">simtime_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasePastry.html">BasePastry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f">overlay</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to the main pastry module  <a href="#a81308a19594555ad39b7a35a26bf0e4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a>, <br class="typebreak"/>
<a class="el" href="structPLSRepairData.html">PLSRepairData</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classPastryLeafSet.html" title="PastryLeafSet module.">PastryLeafSet</a> module. </p>
<p>This module contains the LeafSet of the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> implementation.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Felix Palmen </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00060">60</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aec4b33e2ef0b6bcf7e9803102f5bd174"></a><!-- doxytag: member="PastryLeafSet::balanceLeafSet" ref="aec4b33e2ef0b6bcf7e9803102f5bd174" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::balanceLeafSet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00380">380</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> ||
        (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified() &amp;&amp;
         !(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end() - 2)-&gt;isUnspecified()) ||
        (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified() &amp;&amp;
         !(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + 1)-&gt;isUnspecified()))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    std::vector&lt;NodeHandle&gt;::iterator it_left, it_right;

    <span class="keywordflow">for</span> (it_left = <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>, it_right = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>;
         it_right != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); --it_left, ++it_right) {
        <span class="keywordflow">if</span> (it_left-&gt;isUnspecified()) {
            <span class="keywordflow">if</span> (it_right-&gt;isUnspecified() ||
                (it_right + 1) == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end() ||
                (it_right + 1)-&gt;isUnspecified()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            *it_left = *(it_right + 1);
            *(it_right + 1) = <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (it_right-&gt;isUnspecified()) {

            <span class="keywordflow">if</span> (it_left == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() ||
                (it_left - 1)-&gt;isUnspecified()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            *it_right = *(it_left - 1);
            *(it_left - 1) = <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// should not happen</span>
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8e35d7891d1a32e48fce420555ff2b4d"></a><!-- doxytag: member="PastryLeafSet::createSiblingVector" ref="a8e35d7891d1a32e48fce420555ff2b4d" args="(const OverlayKey &amp;key, int numSiblings) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseKeySortedVector.html">NodeVector</a> * PastryLeafSet::createSiblingVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numSiblings</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00220">220</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01100">BasePastry::findNode()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00919">BasePastry::isSiblingFor()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    <span class="comment">// create temporary comparator</span>
    <a class="code" href="classKeyDistanceComparator.html" title="OverlayKey distance comparator.">KeyDistanceComparator&lt;KeyRingMetric&gt;</a>* comp =
        <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html" title="OverlayKey distance comparator.">KeyDistanceComparator&lt;KeyRingMetric&gt;</a>( key );

    <span class="comment">// create result vector</span>
    <a class="code" href="classBaseKeySortedVector.html">NodeVector</a>* result = <span class="keyword">new</span> <a class="code" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a>( numSiblings, comp );

    result-&gt;add(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>);

    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++) {
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified()) {
            result-&gt;add(*it);
        }
    }

    <span class="keyword">delete</span> comp;

    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#ae13d5a42c50606e3cc0fbcd830429322" title="check if LeafSet knows at least one node to the left and to the right">isValid</a>()) {
        <span class="keywordflow">return</span> result;
    }

    <span class="comment">// if the leafset is not full, we could have a very small network</span>
    <span class="comment">// =&gt; return true (FIXME hack)</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified() || <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified()) {
        <span class="keywordflow">return</span> result;
    }

    <span class="keywordflow">if</span> ((result-&gt;contains(<a class="code" href="classPastryLeafSet.html#a9b1713cff5c488d9eb918107dd735514" title="return the biggest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getBiggestKey</a>())) ||
        (result-&gt;contains(<a class="code" href="classPastryLeafSet.html#a7eae5839ee4ef18bf37984cbc99ce11e" title="return the smallest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getSmallestKey</a>()))) {
        <span class="keyword">delete</span> result;
        <span class="keywordflow">return</span> NULL;
    }

    <span class="keywordflow">return</span> result;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a86d0046df97f4d54384d2a0b3936c53e"></a><!-- doxytag: member="PastryLeafSet::dumpToStateMessage" ref="a86d0046df97f4d54384d2a0b3936c53e" args="(PastryStateMessage *msg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::dumpToStateMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>dump content of the set to a <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>the <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a> to be filled with entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPastryStateObject.html#a6df4273e063990435c7766cae4f1b83a">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00163">163</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00082">Bamboo::changeState()</a>, <a class="el" href="Pastry_8cc_source.html#l00650">Pastry::doSecondStage()</a>, <a class="el" href="BasePastry_8cc_source.html#l00805">BasePastry::sendLeafset()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00571">BasePastry::sendStateTables()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    uint32_t i = 0;
    uint32_t size = 0;
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    msg-&gt;<a class="code" href="classPastryStateMessage.html#ac3f254bf54612f480dde0eef3a1204bf">setLeafSetArraySize</a>(<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>);
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++) {
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified()) {
            ++size;
            msg-&gt;<a class="code" href="classPastryStateMessage.html#ad8e9818e66d5e66ca42d2279245bdbfc">setLeafSet</a>(i++, *it);
        }
    }
    msg-&gt;<a class="code" href="classPastryStateMessage.html#ac3f254bf54612f480dde0eef3a1204bf">setLeafSetArraySize</a>(size);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a305d1f6be0b34ee3349b725a6039d0b9"></a><!-- doxytag: member="PastryLeafSet::dumpToStateMessage" ref="a305d1f6be0b34ee3349b725a6039d0b9" args="(PastryLeafsetMessage *msg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::dumpToStateMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPastryLeafsetMessage.html">PastryLeafsetMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>dump content of the set to a <a class="el" href="classPastryLeafsetMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryLeafsetMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>the <a class="el" href="classPastryLeafsetMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryLeafsetMessage</a> to be filled with entries </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00180">180</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    uint32_t i = 0;
    uint32_t size = 0;
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    msg-&gt;<a class="code" href="classPastryLeafsetMessage.html#a2ec2d3349eae605a61b55ae7eeff9bc5">setLeafSetArraySize</a>(<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>);
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++) {
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified()) {
            ++size;
            msg-&gt;<a class="code" href="classPastryLeafsetMessage.html#add572a645bf78777bf01fafcba10659c">setLeafSet</a>(i++, *it);
        }
    }
    msg-&gt;<a class="code" href="classPastryLeafsetMessage.html#a2ec2d3349eae605a61b55ae7eeff9bc5">setLeafSetArraySize</a>(size);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a529939c1a02749c1b18300404172c6ad"></a><!-- doxytag: member="PastryLeafSet::dumpToVector" ref="a529939c1a02749c1b18300404172c6ad" args="(std::vector&lt; TransportAddress &gt; &amp;affected) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::dumpToVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>affected</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appends all leaf set entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>affected</em>&nbsp;</td><td>the vector to fill with leaf set entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPastryStateObject.html#ac677c6c0df6213694165eb3ee912c85e">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00412">412</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00149">Pastry::changeState()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++)
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified())
            affected.push_back(*it);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a606dbf99943147de93fef16e9bc4bb1f"></a><!-- doxytag: member="PastryLeafSet::earlyInit" ref="a606dbf99943147de93fef16e9bc4bb1f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::earlyInit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize watches etc. </p>

<p>Implements <a class="el" href="classPastryStateObject.html#a711a095dc7d08c3ee45c4f8bdaf27fce">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00053">53</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    WATCH_VECTOR(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad691bdd611ba773d5b7a0a90af491498"></a><!-- doxytag: member="PastryLeafSet::failedNode" ref="ad691bdd611ba773d5b7a0a90af491498" args="(const TransportAddress &amp;failed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryLeafSet::failedNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>failed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells the leafset that a node has failed </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>failed</em>&nbsp;</td><td>the failed node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#aac3ee89c4129465def00861424f232e3">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00486">486</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00725">Pastry::handleFailedNode()</a>, and <a class="el" href="Bamboo_8cc_source.html#l00407">Bamboo::handleFailedNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::iterator i;
    <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* ask;
    <span class="keywordtype">bool</span> left = <span class="keyword">true</span>;

    <span class="comment">// search failed node in leafset:</span>
    <span class="keywordflow">for</span> (i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); i != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); i++) {
        <span class="keywordflow">if</span> (i == <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>) left = <span class="keyword">false</span>;
        <span class="keywordflow">if</span> ((! i-&gt;isUnspecified()) &amp;&amp; (i-&gt;getIp() == failed.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>())) <span class="keywordflow">break</span>;
    }

    <span class="comment">// failed node not in leafset:</span>
    <span class="keywordflow">if</span> (i == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end()) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(*i, <span class="keyword">false</span>);

    <span class="comment">// remove failed node:</span>
    <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.erase(i);
    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">true</span>;

    <a class="code" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a> = <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a>;
    <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;

    <span class="comment">// insert UNSPECIFIED_NODE at front or back and return correct node</span>
    <span class="comment">// to ask for repair:</span>
    <span class="keywordflow">if</span> (left) {
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.insert(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(), <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>);
        <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
        <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;
        ask = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>*<span class="keyword">&gt;</span>(&amp;(<a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>()));
    } <span class="keywordflow">else</span> {
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.push_back(<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>);
        <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
        <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;
        ask = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>*<span class="keyword">&gt;</span>(&amp;(<a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>()));
    }

    assert(ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || *ask != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    <a class="code" href="classPastryLeafSet.html#aec4b33e2ef0b6bcf7e9803102f5bd174">balanceLeafSet</a>();
    <a class="code" href="PastryLeafSet_8cc.html#a2b96f0bd3a00d62f9b701dde3155f44a">LEAF_TEST</a>();

    assert(ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || *ask != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    <span class="keywordflow">if</span> (! ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>())
        <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>[*ask] = <a class="code" href="structPLSRepairData.html" title="struct for tracking repair requests">PLSRepairData</a>(simTime(), left);

    <span class="keywordflow">return</span> *ask;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae42c594976b0f7dbc1a24269b3cc6c89"></a><!-- doxytag: member="PastryLeafSet::findCloserNode" ref="ae42c594976b0f7dbc1a24269b3cc6c89" args="(const OverlayKey &amp;destination, bool optimize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::findCloserNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>optimize</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>try to find a node numerically closer to a given key with the same shared prefix as the current node in the leaf set. </p>
<p>this method is to be called, when a regular next hop couldn't be found or wasn't reachable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the destination key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optimize</em>&nbsp;</td><td>if set, check all nodes and return the best/closest one </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a closer <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if none was found </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#a5bc159769dfdcd95ceaaf6055798b743">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00458">458</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01100">BasePastry::findNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i;
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* ret = &amp;<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;

    <span class="comment">// this will only be called after getDestinationNode() returned</span>
    <span class="comment">// NodeHandle::UNSPECIFIED_NODE, so a closer Node can only be the biggest</span>
    <span class="comment">// or the smallest node in the LeafSet.</span>

    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; smallest = <a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>();
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; biggest = <a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>();

    <span class="keywordflow">if</span> ((!smallest.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
            (<a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(smallest, destination, *ret))) {
        <span class="keywordflow">if</span> (optimize) ret = &amp;smallest;
        <span class="keywordflow">else</span> <span class="keywordflow">return</span> smallest;
    }

    <span class="keywordflow">if</span> ((!biggest.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
            (<a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(biggest, destination, *ret))) {
        <span class="keywordflow">if</span> (optimize) ret = &amp;biggest;
        <span class="keywordflow">else</span> <span class="keywordflow">return</span> biggest;
    }

    <span class="keywordflow">return</span> *ret;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a54cf1b5716243dc9ea4f840e3076c720"></a><!-- doxytag: member="PastryLeafSet::findCloserNodes" ref="a54cf1b5716243dc9ea4f840e3076c720" args="(const OverlayKey &amp;destination, NodeVector *nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::findCloserNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBaseKeySortedVector.html">NodeVector</a> *&nbsp;</td>
          <td class="paramname"> <em>nodes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classPastryStateObject.html#a5255b15a989fb6f61403760383618375">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00447">447</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01100">BasePastry::findNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++)
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified())
            nodes-&gt;<a class="code" href="classBaseKeySortedVector.html#a3fdb759e6bb3232ec8ce9d572637429e" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(*it);

}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9b1713cff5c488d9eb918107dd735514"></a><!-- doxytag: member="PastryLeafSet::getBiggestKey" ref="a9b1713cff5c488d9eb918107dd735514" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp; PastryLeafSet::getBiggestKey </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the biggest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>biggest key in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00442">442</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00220">createSiblingVector()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00106">getDestinationNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>();
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5b83a6b8a5ef6ad328b88710ea1164b8"></a><!-- doxytag: member="PastryLeafSet::getBiggestNode" ref="a5b83a6b8a5ef6ad328b88710ea1164b8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getBiggestNode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the node with the biggest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>biggest node in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00434">434</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00458">findCloserNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00442">getBiggestKey()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00537">repair()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end()-1;
    <span class="keywordflow">while</span> ((i-&gt;isUnspecified()) &amp;&amp; (i != <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>)) i--;
    assert(i-&gt;isUnspecified() || *i != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());
    <span class="keywordflow">return</span> *i;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8d3bbe87fe682fc513a83df7a0d69f57"></a><!-- doxytag: member="PastryLeafSet::getDestinationNode" ref="a8d3bbe87fe682fc513a83df7a0d69f57" args="(const OverlayKey &amp;destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getDestinationNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the final node according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the destination key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of the final node or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if given destination key is outside the leaf set </dd></dl>

<p>Reimplemented from <a class="el" href="classPastryStateObject.html#a6837869040021974c136f43630a563b2">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00106">106</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01100">BasePastry::findNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* smallest;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* biggest;
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* ret = &amp;<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;

    <span class="comment">// check whether destination is inside leafSet:</span>

    smallest = &amp;(<a class="code" href="classPastryLeafSet.html#a7eae5839ee4ef18bf37984cbc99ce11e" title="return the smallest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getSmallestKey</a>());
    biggest = &amp;(<a class="code" href="classPastryLeafSet.html#a9b1713cff5c488d9eb918107dd735514" title="return the biggest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getBiggestKey</a>());
    <span class="keywordflow">if</span> (smallest-&gt;<a class="code" href="classOverlayKey.html#abe357a4d1babcf7d30598a61cbc0f5c2" title="Returns true, if the key is unspecified.">isUnspecified</a>()) smallest = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());
    <span class="keywordflow">if</span> (biggest-&gt;<a class="code" href="classOverlayKey.html#abe357a4d1babcf7d30598a61cbc0f5c2" title="Returns true, if the key is unspecified.">isUnspecified</a>()) biggest = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());

    <span class="keywordflow">if</span> (!destination.<a class="code" href="classOverlayKey.html#af35313562131a78724e31297889be822" title="Returns true, if this key is element of the interval [keyA, keyB] on the ring.">isBetweenLR</a>(*smallest, *biggest)) <span class="keywordflow">return</span> *ret;

    <span class="comment">// find the closest node:</span>

    <span class="keywordflow">for</span> (i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); i != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); i++) {
        <span class="keywordflow">if</span> (i-&gt;isUnspecified()) <span class="keywordflow">continue</span>;

        <span class="comment">// note for next line:</span>
        <span class="comment">// * dereferences iterator, &amp; gets address of element.</span>
        <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(*i, destination, *ret)) ret = &amp;(*i);
    }

    <span class="keywordflow">return</span> *ret;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d51346450731df0d955386d19f45f72"></a><!-- doxytag: member="PastryLeafSet::getNewLeafsMessage" ref="a3d51346450731df0d955386d19f45f72" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPastryNewLeafsMessage.html">PastryNewLeafsMessage</a> * PastryLeafSet::getNewLeafsMessage </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>generates a newLeafs-message if LeafSet changed since last call to this method. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to newLeafs-message or NULL </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00588">588</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00274">BasePastry::newLeafs()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;
    <a class="code" href="classPastryNewLeafsMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryNewLeafsMessage</a>* msg;
    uint32_t i = 0;

    <span class="keywordflow">if</span> (! <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a>) <span class="keywordflow">return</span> NULL;
    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">false</span>;

    msg = <span class="keyword">new</span> <a class="code" href="classPastryNewLeafsMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryNewLeafsMessage</a>(<span class="stringliteral">&quot;PastryNewLeafs&quot;</span>);

    msg-&gt;<a class="code" href="classPastryNewLeafsMessage.html#ac7fb420b7b5be4e2b6d16a2ac58678c0">setLeafsArraySize</a>(<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>);
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++)
        msg-&gt;<a class="code" href="classPastryNewLeafsMessage.html#a5504df8175d91ed8c17a1f4547457fd1">setLeafs</a>(i++, *it);

    msg-&gt;setBitLength(<a class="code" href="PastryMessage__m_8h.html#a811621e4068a33905b600d418168fae8">PASTRYNEWLEAFS_L</a>(msg));
    <span class="keywordflow">return</span> msg;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa6b310e05c4fd88e015092740665e98f"></a><!-- doxytag: member="PastryLeafSet::getPredecessor" ref="aa6b310e05c4fd88e015092740665e98f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getPredecessor </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return predecessor node for visualizing </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00096">96</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00973">BasePastry::updateTooltip()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> *<a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a76dca71b4a758f9aec046e1626b5a42e"></a><!-- doxytag: member="PastryLeafSet::getRandomNode" ref="a76dca71b4a758f9aec046e1626b5a42e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryLeafSet::getRandomNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a random node from the leafset </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a random node or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00196">196</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00318">Bamboo::doLeafsetMaintenance()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">//std::vector&lt;NodeHandle&gt;::iterator i;</span>
    uint32_t rnd;
    <span class="keywordtype">int</span> i;

    rnd = intuniform(0, <a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> - 1, 0);
    i = rnd;
    <span class="comment">//while (rnd &lt; leaves.size()) {</span>
    <span class="keywordflow">while</span> (i &lt; (<span class="keywordtype">int</span>)<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.size()) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].isUnspecified()) <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i];
        <span class="keywordflow">else</span> i++;<span class="comment">//rnd++;</span>
    }
    i = rnd;
    <span class="keywordflow">while</span> (i &gt;= 0) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].isUnspecified()) <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i];
        <span class="keywordflow">else</span> i--;
    }
    EV &lt;&lt; <span class="stringliteral">&quot;Leafset::getRandomNode() returns UNSPECIFIED_NODE&quot;</span>
          <span class="stringliteral">&quot;Leafset empty??&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7eae5839ee4ef18bf37984cbc99ce11e"></a><!-- doxytag: member="PastryLeafSet::getSmallestKey" ref="a7eae5839ee4ef18bf37984cbc99ce11e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp; PastryLeafSet::getSmallestKey </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the smallest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>smallest key in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00429">429</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00220">createSiblingVector()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00106">getDestinationNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>();
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a95c6d44e09bd76f79a11f097bf05e727"></a><!-- doxytag: member="PastryLeafSet::getSmallestNode" ref="a95c6d44e09bd76f79a11f097bf05e727" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getSmallestNode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the node with the smallest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>smallest node in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00421">421</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00458">findCloserNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00429">getSmallestKey()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00537">repair()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin();
    <span class="keywordflow">while</span> ((i-&gt;isUnspecified()) &amp;&amp; (i != <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>)) i++;
    assert(i-&gt;isUnspecified() || *i != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());
    <span class="keywordflow">return</span> *i;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab613105c42c31ecf5b4353a213036b63"></a><!-- doxytag: member="PastryLeafSet::getSuccessor" ref="ab613105c42c31ecf5b4353a213036b63" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getSuccessor </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return successor node for visualizing </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00091">91</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00973">BasePastry::updateTooltip()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> *<a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa2c78d769e86e656409342e553c9af0a"></a><!-- doxytag: member="PastryLeafSet::initializeSet" ref="aa2c78d769e86e656409342e553c9af0a" args="(uint32_t numberOfLeaves, uint32_t bitsPerDigit, simtime_t repairTimeout, const NodeHandle &amp;owner, BasePastry *overlay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::initializeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>numberOfLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bitsPerDigit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>repairTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasePastry.html">BasePastry</a> *&nbsp;</td>
          <td class="paramname"> <em>overlay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the leaf set. </p>
<p>This should be called on startup</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numberOfLeaves</em>&nbsp;</td><td><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> configuration parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitsPerDigit</em>&nbsp;</td><td>number of bits per digits </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>repairTimeout</em>&nbsp;</td><td><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> configuration parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>the node this table belongs to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlay</em>&nbsp;</td><td>pointer to the pastry main module </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00058">58</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00196">BasePastry::baseChangeState()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> % 2) <span class="keywordflow">throw</span> <span class="stringliteral">&quot;numberOfLeaves must be even.&quot;</span>;

    this-&gt;owner = owner;
    this-&gt;<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> = <a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>;
    this-&gt;<a class="code" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a> = <a class="code" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a>;
    this-&gt;<a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a> = <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>;
    this-&gt;overlay = overlay;

    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.empty()) <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.clear();

    <span class="comment">// fill Set with unspecified node handles</span>
    <span class="keywordflow">for</span> (uint32_t i = <a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>; i&gt;0; i--)
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.push_back(<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>);

    <span class="comment">// initialize iterators to mark the beginning of bigger/smaller keys</span>
    <span class="comment">// in the set</span>
    <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
    <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;

    <span class="comment">// reset repair marker:</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.empty()) <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.clear();

    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">false</span>;
    <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;
    <a class="code" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a> = <span class="keyword">false</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac563e858547e96db005896f8d822d84b"></a><!-- doxytag: member="PastryLeafSet::insertLeaf" ref="ac563e858547e96db005896f8d822d84b" args="(std::vector&lt; NodeHandle &gt;::iterator &amp;it, const NodeHandle &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::insertLeaf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>insert a leaf at a given position </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>iterator where to insert the new leaf </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td><a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of new leaf </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00329">329</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00261">mergeNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    assert(node != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    <a class="code" href="PastryLeafSet_8cc.html#a2b96f0bd3a00d62f9b701dde3155f44a">LEAF_TEST</a>();
    <span class="keywordtype">bool</span> issmaller = (it &lt;= <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>);
    <span class="keywordflow">if</span> (issmaller) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified())  {
            <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front(), <span class="keyword">false</span>);
        }
        <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(node, <span class="keyword">true</span>);

        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.insert(++it, node);
        <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; temp = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front();
        <span class="keywordflow">if</span> (!temp.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>() &amp;&amp; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified()) {
            <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back() = temp;
        }
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.erase(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin());


    } <span class="keywordflow">else</span> {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified())  {
            <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back(), <span class="keyword">false</span>);
        }
        <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(node, <span class="keyword">true</span>);

        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.insert(it, node);
        <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; temp = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back();
        <span class="keywordflow">if</span> (!temp.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>() &amp;&amp; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified()) {
            <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front() = temp;
        }
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.pop_back();
    }

    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified() &amp;&amp;
        !<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified()) {
        <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;

    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">true</span>;
    <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
    <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;

    <span class="comment">// ensure balance in leafset</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a>) {
        <a class="code" href="classPastryLeafSet.html#aec4b33e2ef0b6bcf7e9803102f5bd174">balanceLeafSet</a>();
    }
    <a class="code" href="PastryLeafSet_8cc.html#a2b96f0bd3a00d62f9b701dde3155f44a">LEAF_TEST</a>();
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa525adf4fc0334d812fbb70a50b78ca5"></a><!-- doxytag: member="PastryLeafSet::isClosestNode" ref="aa525adf4fc0334d812fbb70a50b78ca5" args="(const OverlayKey &amp;destination) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::isClosestNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>checks if we are the closest node to key destination in the overlay </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the key to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we are closest to given key </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00136">136</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01100">BasePastry::findNode()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00919">BasePastry::isSiblingFor()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">// check for simple cases first</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>() == destination) {
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>-&gt;isUnspecified() &amp;&amp; <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>-&gt;isUnspecified()) {
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// check if the next bigger or smaller node in the set is closer</span>
    <span class="comment">// than own node</span>
    <span class="keywordtype">bool</span> biggerIsCloser = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> smallerIsCloser = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (! <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>-&gt;isUnspecified()) {
        biggerIsCloser = <a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(*<a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>, destination);
    }
    <span class="keywordflow">if</span> (! <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>-&gt;isUnspecified()) {
        smallerIsCloser = <a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(*<a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>, destination);
    }

    <span class="comment">// return true if both are not closer</span>
    <span class="keywordflow">return</span> ((!biggerIsCloser) &amp;&amp; (!smallerIsCloser));
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aafdca32c4ad0049c6b260ae61cc5a8f5"></a><!-- doxytag: member="PastryLeafSet::isLeft" ref="aafdca32c4ad0049c6b260ae61cc5a8f5" args="(const OverlayKey &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::isLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if a given key should be placed on the left or on the right side of the leaf set </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>key to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if key belongs to the left </dd></dl>

</div>
</div>
<a class="anchor" id="ae13d5a42c50606e3cc0fbcd830429322"></a><!-- doxytag: member="PastryLeafSet::isValid" ref="ae13d5a42c50606e3cc0fbcd830429322" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::isValid </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>check if LeafSet knows at least one node to the left and to the right </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00101">101</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00220">createSiblingVector()</a>, <a class="el" href="Pastry_8cc_source.html#l00650">Pastry::doSecondStage()</a>, <a class="el" href="Pastry_8cc_source.html#l00725">Pastry::handleFailedNode()</a>, and <a class="el" href="Bamboo_8cc_source.html#l00407">Bamboo::handleFailedNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> (!(<a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>-&gt;isUnspecified() || <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>-&gt;isUnspecified()));
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1e19ba86f8c54fdab06a8aed85a8c95f"></a><!-- doxytag: member="PastryLeafSet::mergeNode" ref="a1e19ba86f8c54fdab06a8aed85a8c95f" args="(const NodeHandle &amp;node, simtime_t prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::mergeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>prox</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>merge a node into LeafSet </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node to merge </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prox</em>&nbsp;</td><td>the proximity value of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if node was merged </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00261">261</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    assert(node != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    std::vector&lt;NodeHandle&gt;::iterator it, it_left, it_right;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* last_left = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* last_right = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());

    it_left = <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>;
    it_right = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>;

    <span class="comment">// avoid duplicates</span>
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); ++it) {
        <span class="keywordflow">if</span> (it-&gt;isUnspecified()) {
            <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;
            <span class="keywordflow">continue</span>;
        }
        <span class="keywordflow">if</span> (it-&gt;getKey() == node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// look for correct position in left and right half of leafset</span>
    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
        <span class="keywordflow">if</span>(!<a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a>) {
            <span class="comment">// both sides free</span>
            <span class="keywordflow">if</span>(it_left-&gt;getKey().isUnspecified() &amp;&amp;
               it_right-&gt;getKey().isUnspecified()) {
                <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_left, node);
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
            <span class="keywordflow">if</span> (it_left-&gt;getKey().isUnspecified() &amp;&amp;
                !node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(*last_right, it_right-&gt;getKey())) {
                <span class="comment">// end of smaller entries found</span>
                <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_left, node);
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
            <span class="keywordflow">if</span> (it_right-&gt;getKey().isUnspecified() &amp;&amp;
                !node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(it_left-&gt;getKey(), *last_left)) {
                <span class="comment">// end of bigger entries found</span>
                <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_right, node);
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="comment">// left side</span>
        <span class="keywordflow">if</span> (node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(it_left-&gt;getKey(), *last_left)) {
            <span class="comment">// found correct position for inserting the new entry between</span>
            <span class="comment">// existing ones</span>
            <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_left, node);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
        <span class="comment">// right side</span>
        <span class="keywordflow">if</span> (node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(*last_right, it_right-&gt;getKey())) {
            <span class="comment">// found correct position for inserting the new entry between</span>
            <span class="comment">// existing ones</span>
            <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_right, node);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }

        last_right = &amp;(it_right-&gt;getKey());
        ++it_right;

        <span class="keywordflow">if</span> (it_right == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end()) <span class="keywordflow">break</span>;

        last_left = &amp;(it_left-&gt;getKey());
        --it_left;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aee63679544eb8ea21dbbf4d5dc7ef330"></a><!-- doxytag: member="PastryLeafSet::repair" ref="aee63679544eb8ea21dbbf4d5dc7ef330" args="(const PastryStateMessage *msg, const PastryStateMsgProximity *prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryLeafSet::repair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *&nbsp;</td>
          <td class="paramname"> <em>prox</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>attempt to repair the leafset using a received REPAIR message </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>the state message of type REPAIR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prox</em>&nbsp;</td><td>record of proximity values matching the state message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>another node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00537">537</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l01071">Pastry::handleStateMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    std::map&lt;TransportAddress, PLSRepairData&gt;::iterator it;
    <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* ask;
    <span class="keywordtype">bool</span> left;

    simtime_t now = simTime();

    <span class="comment">// first eliminate outdated entries in awaitingRepair:</span>
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.end();) {
        <span class="keywordflow">if</span> (it-&gt;second.ts &lt; (now - <a class="code" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a>)) {
            <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.erase(it++);
        }
        <span class="keywordflow">else</span> it++;
    }

    <span class="comment">// don&#39;t expect any more repair messages:</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.empty()) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// look for source node in our list:</span>
    <span class="keywordflow">if</span> ( (it = <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.find(msg-&gt;<a class="code" href="classPastryStateMessage.html#ab854faec5faca431685829ba8296ecfd">getSender</a>())) == <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.end() )
        <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// which side of the LeafSet is affected:</span>
    left = it-&gt;second.left;

    <span class="comment">// remove source node from list:</span>
    <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.erase(it);

    <span class="comment">// merge info from repair message:</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#a36f82233ec05837bf3761057f2437c86" title="update own state based on a received PastryStateMessage">mergeState</a>(msg, prox) || <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> || !<a class="code" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a>) {
        EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::repair()]\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot;    LeafSet repair was successful.&quot;</span>
           &lt;&lt; endl;
        <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
    } <span class="keywordflow">else</span> {
        <span class="comment">// repair did not succeed, try again:</span>
        ask = &amp;( left ? <a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>() : <a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>() );
        <span class="keywordflow">if</span> (ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || *ask == msg-&gt;<a class="code" href="classPastryStateMessage.html#ab854faec5faca431685829ba8296ecfd">getSender</a>()) {
            EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::repair()]\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;    LeafSet giving up repair attempt.&quot;</span>
               &lt;&lt; endl;
            <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
        } <span class="keywordflow">else</span> {
            <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>[*ask] = <a class="code" href="structPLSRepairData.html" title="struct for tracking repair requests">PLSRepairData</a>(simTime(), left);
        }
        <span class="keywordflow">return</span> *ask;
    }
}
</pre></div></p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae5272dfe11057414c1651eb4d3eca5ee"></a><!-- doxytag: member="PastryLeafSet::awaitingRepair" ref="ae5272dfe11057414c1651eb4d3eca5ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classTransportAddress.html">TransportAddress</a>, <a class="el" href="structPLSRepairData.html">PLSRepairData</a>&gt; <a class="el" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">PastryLeafSet::awaitingRepair</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00203">203</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00537">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7935e96df4a1e07256e1f456f8e57a0"></a><!-- doxytag: member="PastryLeafSet::bigger" ref="ad7935e96df4a1e07256e1f456f8e57a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classNodeHandle.html">NodeHandle</a>&gt;::iterator <a class="el" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">PastryLeafSet::bigger</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00201">201</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00380">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00434">getBiggestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00091">getSuccessor()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00136">isClosestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00101">isValid()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00261">mergeNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a603a986ef0e87c7ad4e0f8e23d46adf7"></a><!-- doxytag: member="PastryLeafSet::isFull" ref="a603a986ef0e87c7ad4e0f8e23d46adf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">PastryLeafSet::isFull</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00207">207</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00380">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00261">mergeNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00537">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="afef9535e5da8a4151381d31df20e37a6"></a><!-- doxytag: member="PastryLeafSet::leaves" ref="afef9535e5da8a4151381d31df20e37a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classNodeHandle.html">NodeHandle</a>&gt; <a class="el" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">PastryLeafSet::leaves</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00199">199</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00380">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00220">createSiblingVector()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00163">dumpToStateMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00412">dumpToVector()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00053">earlyInit()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00447">findCloserNodes()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00434">getBiggestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00106">getDestinationNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00588">getNewLeafsMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00196">getRandomNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00421">getSmallestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00261">mergeNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a433ea4e50c2d5f458d5c91c16f6fc8da"></a><!-- doxytag: member="PastryLeafSet::newLeafs" ref="a433ea4e50c2d5f458d5c91c16f6fc8da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">PastryLeafSet::newLeafs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00205">205</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00588">getNewLeafsMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b79dd7347229e4661b0b9d34f6909fc"></a><!-- doxytag: member="PastryLeafSet::numberOfLeaves" ref="a2b79dd7347229e4661b0b9d34f6909fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">PastryLeafSet::numberOfLeaves</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00196">196</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00163">dumpToStateMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00588">getNewLeafsMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00196">getRandomNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="a81308a19594555ad39b7a35a26bf0e4f"></a><!-- doxytag: member="PastryLeafSet::overlay" ref="a81308a19594555ad39b7a35a26bf0e4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasePastry.html">BasePastry</a>* <a class="el" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f">PastryLeafSet::overlay</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the main pastry module </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00198">198</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00434">getBiggestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00421">getSmallestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00261">mergeNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a314a62c6e53224ba6de785f5754fcc41"></a><!-- doxytag: member="PastryLeafSet::repairTimeout" ref="a314a62c6e53224ba6de785f5754fcc41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t <a class="el" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">PastryLeafSet::repairTimeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00197">197</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00537">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b2af0d1e896f6879a5977536499e123"></a><!-- doxytag: member="PastryLeafSet::smaller" ref="a1b2af0d1e896f6879a5977536499e123" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classNodeHandle.html">NodeHandle</a>&gt;::iterator <a class="el" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">PastryLeafSet::smaller</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00200">200</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00380">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00096">getPredecessor()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00421">getSmallestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00329">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00136">isClosestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00101">isValid()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00261">mergeNode()</a>.</p>

</div>
</div>
<a class="anchor" id="abb1d399d03a2768881b272ed93f786a4"></a><!-- doxytag: member="PastryLeafSet::wasFull" ref="abb1d399d03a2768881b272ed93f786a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">PastryLeafSet::wasFull</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00208">208</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00486">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00058">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00537">repair()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a></li>
<li><a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 3 2010 14:40:53 for OverSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
