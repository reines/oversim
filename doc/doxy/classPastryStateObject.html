<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: PastryStateObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<h1>PastryStateObject Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PastryStateObject" -->
<p><a class="el" href="classPastryStateObject.html" title="PastryStateObject Module.">PastryStateObject</a> Module.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PastryStateObject:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPastryStateObject.png" usemap="#PastryStateObject_map" alt=""/>
  <map id="PastryStateObject_map" name="PastryStateObject_map">
<area href="classPastryLeafSet.html" alt="PastryLeafSet" shape="rect" coords="0,56,146,80"/>
<area href="classPastryNeighborhoodSet.html" alt="PastryNeighborhoodSet" shape="rect" coords="156,56,302,80"/>
<area href="classPastryRoutingTable.html" alt="PastryRoutingTable" shape="rect" coords="312,56,458,80"/>
</map>
</div>

<p><a href="classPastryStateObject-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#abb6493e3c98f1e6e693137c121cf1767">handleMessage</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#ab32d468bd497367a3f993fd90de46982">numInitStages</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#adf826ec538628fcb93496441c873be4d">initialize</a> (int stage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a6837869040021974c136f43630a563b2">getDestinationNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the final node according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme.  <a href="#a6837869040021974c136f43630a563b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a5bc159769dfdcd95ceaaf6055798b743">findCloserNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, bool optimize=false)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to find a node numerically closer to a given key with the same shared prefix as the current node in the state table.  <a href="#a5bc159769dfdcd95ceaaf6055798b743"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a5255b15a989fb6f61403760383618375">findCloserNodes</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, <a class="el" href="classBaseKeySortedVector.html">NodeVector</a> *nodes)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#aac3ee89c4129465def00861424f232e3">failedNode</a> (const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;failed)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">do something about a failed node  <a href="#aac3ee89c4129465def00861424f232e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a70220d25c9d51c068189884d973f45dc">repair</a> (const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> &amp;prox)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">attempt to repair state using a received REPAIR message  <a href="#a70220d25c9d51c068189884d973f45dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a6df4273e063990435c7766cae4f1b83a">dumpToStateMessage</a> (<a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dump content of the set to a <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a>  <a href="#a6df4273e063990435c7766cae4f1b83a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a36f82233ec05837bf3761057f2437c86">mergeState</a> (const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *prox)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">update own state based on a received <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a>  <a href="#a36f82233ec05837bf3761057f2437c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#ac677c6c0df6213694165eb3ee912c85e">dumpToVector</a> (std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;affected) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">append all entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining.  <a href="#ac677c6c0df6213694165eb3ee912c85e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917">isCloser</a> (const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;test, const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;reference=<a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6">NodeHandle::UNSPECIFIED_NODE</a>) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test a given <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> if it is closer to a given destination  <a href="#ace8eed35caedb59412a49132c4538917"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993">specialCloserCondition</a> (const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;test, const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;reference=<a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6">NodeHandle::UNSPECIFIED_NODE</a>) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test a given <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> if it is closer to a given destination, but only if the shared prefix length with the destination is at least equal to the shared prefix length with our own node  <a href="#a13a6c5fdcbe191dc45619aeaa29f1993"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structPastryExtendedNode.html">PastryExtendedNode</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a957e9ac8870e9f03df83f85ff4d8cf7b">unspecNode</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNodeHandle.html">NodeHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc">owner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">stores the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of the owner of this <a class="el" href="classPastryStateObject.html" title="PastryStateObject Module.">PastryStateObject</a>.  <a href="#a946cabf3c3e981122e05bb37bf1c95dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a711a095dc7d08c3ee45c4f8bdaf27fce">earlyInit</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize watches etc.  <a href="#a711a095dc7d08c3ee45c4f8bdaf27fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7">mergeNode</a> (const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;node, simtime_t prox)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to merge a single node in the state table  <a href="#aa5029ce2c80ae1a744ea92efc02dc8a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOverlayKey.html">OverlayKey</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a182dd91bf8a093548c63b3a48caf558e">keyDist</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;a, const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the distance of two keys on the ring  <a href="#a182dd91bf8a093548c63b3a48caf558e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structPastryExtendedNode.html">PastryExtendedNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryStateObject.html#a828ca53b6489299c05fcc898cdd185c5">_unspecNode</a> = NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified Node with proximity  <a href="#a828ca53b6489299c05fcc898cdd185c5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classPastryStateObject.html" title="PastryStateObject Module.">PastryStateObject</a> Module. </p>
<p>This module class describes the common interface of all <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> State Objects and implements what all have in common</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Felix Palmen </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPastryRoutingTable.html" title="Routing table module.">PastryRoutingTable</a>, LeafSet, NeighborhoodSet </dd></dl>

<p>Definition at line <a class="el" href="PastryStateObject_8h_source.html#l00047">47</a> of file <a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6df4273e063990435c7766cae4f1b83a"></a><!-- doxytag: member="PastryStateObject::dumpToStateMessage" ref="a6df4273e063990435c7766cae4f1b83a" args="(PastryStateMessage *msg) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PastryStateObject::dumpToStateMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>dump content of the set to a <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>the <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a> to be filled with entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classPastryLeafSet.html#a86d0046df97f4d54384d2a0b3936c53e">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#a401ee530fc0a5b89cfc2ccda3a0a7250">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#a1d4e337dda181b732aa96cd5d5007a42">PastryRoutingTable</a>.</p>

</div>
</div>
<a class="anchor" id="ac677c6c0df6213694165eb3ee912c85e"></a><!-- doxytag: member="PastryStateObject::dumpToVector" ref="ac677c6c0df6213694165eb3ee912c85e" args="(std::vector&lt; TransportAddress &gt; &amp;affected) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PastryStateObject::dumpToVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>affected</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>append all entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>affected</em>&nbsp;</td><td>the vector to fill with entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classPastryLeafSet.html#a529939c1a02749c1b18300404172c6ad">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#ac0741c4c45fb5176e207dadc67a20a03">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#aed1ca355690a9e0354a420bf7c96e3a4">PastryRoutingTable</a>.</p>

</div>
</div>
<a class="anchor" id="a711a095dc7d08c3ee45c4f8bdaf27fce"></a><!-- doxytag: member="PastryStateObject::earlyInit" ref="a711a095dc7d08c3ee45c4f8bdaf27fce" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PastryStateObject::earlyInit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize watches etc. </p>

<p>Implemented in <a class="el" href="classPastryLeafSet.html#a606dbf99943147de93fef16e9bc4bb1f">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#a6eaeba04cfc22f37c8d376b30adc0de9">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#a1c3b854b710dba7cc56abc427980fbec">PastryRoutingTable</a>.</p>

<p>Referenced by <a class="el" href="PastryStateObject_8cc_source.html#l00036">initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="aac3ee89c4129465def00861424f232e3"></a><!-- doxytag: member="PastryStateObject::failedNode" ref="aac3ee89c4129465def00861424f232e3" args="(const TransportAddress &amp;failed)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a>&amp; PastryStateObject::failedNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>failed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>do something about a failed node </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>failed</em>&nbsp;</td><td>the failed node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Implemented in <a class="el" href="classPastryLeafSet.html#ad691bdd611ba773d5b7a0a90af491498">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#a86f227b707f881c8897ec334f2bd5a33">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#ae440c8aa89543afc2147b8784be93c41">PastryRoutingTable</a>.</p>

</div>
</div>
<a class="anchor" id="a5bc159769dfdcd95ceaaf6055798b743"></a><!-- doxytag: member="PastryStateObject::findCloserNode" ref="a5bc159769dfdcd95ceaaf6055798b743" args="(const OverlayKey &amp;destination, bool optimize=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a>&amp; PastryStateObject::findCloserNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>optimize</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>try to find a node numerically closer to a given key with the same shared prefix as the current node in the state table. </p>
<p>this method is to be called, when a regular next hop couldn't be found or wasn't reachable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the destination key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optimize</em>&nbsp;</td><td>if set, check all nodes and return the best/closest one </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a closer <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if none was found </dd></dl>

<p>Implemented in <a class="el" href="classPastryLeafSet.html#ae42c594976b0f7dbc1a24269b3cc6c89">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#aa17a22a731c6aba55fda5ac962df1de3">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#a9f43c06e0a2d98f01c9b3809da0efae6">PastryRoutingTable</a>.</p>

</div>
</div>
<a class="anchor" id="a5255b15a989fb6f61403760383618375"></a><!-- doxytag: member="PastryStateObject::findCloserNodes" ref="a5255b15a989fb6f61403760383618375" args="(const OverlayKey &amp;destination, NodeVector *nodes)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PastryStateObject::findCloserNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBaseKeySortedVector.html">NodeVector</a> *&nbsp;</td>
          <td class="paramname"> <em>nodes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classPastryLeafSet.html#a54cf1b5716243dc9ea4f840e3076c720">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#a1b15fe9598b91dbb26294ed6193235f2">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#a0604bf72a6a6143d4cb8eb6a55e0b0f3">PastryRoutingTable</a>.</p>

</div>
</div>
<a class="anchor" id="a6837869040021974c136f43630a563b2"></a><!-- doxytag: member="PastryStateObject::getDestinationNode" ref="a6837869040021974c136f43630a563b2" args="(const OverlayKey &amp;destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryStateObject::getDestinationNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the final node according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the destination key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of the final node or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if given destination key is outside the leaf set </dd></dl>

<p>Reimplemented in <a class="el" href="classPastryLeafSet.html#a8d3bbe87fe682fc513a83df7a0d69f57">PastryLeafSet</a>.</p>

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00048">48</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="abb6493e3c98f1e6e693137c121cf1767"></a><!-- doxytag: member="PastryStateObject::handleMessage" ref="abb6493e3c98f1e6e693137c121cf1767" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryStateObject::handleMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00043">43</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">throw</span> <span class="stringliteral">&quot;a PastryStateObject should never receive a message.&quot;</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="adf826ec538628fcb93496441c873be4d"></a><!-- doxytag: member="PastryStateObject::initialize" ref="adf826ec538628fcb93496441c873be4d" args="(int stage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryStateObject::initialize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00036">36</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (stage != <a class="code" href="InitStages_8h.html#a42fde1aa1e14a1c45d29061d6e87e532a58e83c497c7c8495e9c592ff3148b6b9" title="first stage for overlay modules (Tier 0 / KBR)">MIN_STAGE_OVERLAY</a>)
        <span class="keywordflow">return</span>;
    <a class="code" href="classPastryStateObject.html#a711a095dc7d08c3ee45c4f8bdaf27fce" title="initialize watches etc.">earlyInit</a>();
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ace8eed35caedb59412a49132c4538917"></a><!-- doxytag: member="PastryStateObject::isCloser" ref="ace8eed35caedb59412a49132c4538917" args="(const NodeHandle &amp;test, const OverlayKey &amp;destination, const NodeHandle &amp;reference=NodeHandle::UNSPECIFIED_NODE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryStateObject::isCloser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>reference</em> = <code><a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6">NodeHandle::UNSPECIFIED_NODE</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test a given <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> if it is closer to a given destination </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the destination Key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reference</em>&nbsp;</td><td><a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> to compare to, own node if unset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if test is closer to destination than owner </dd></dl>

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00134">134</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01100">BasePastry::findNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00106">PastryLeafSet::getDestinationNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00136">PastryLeafSet::isClosestNode()</a>, and <a class="el" href="PastryStateObject_8cc_source.html#l00157">specialCloserCondition()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">// assert: (! test.isUnspecified()) &amp;&amp; (! owner.isUnspecified())</span>

    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* ref = &amp;reference;
    <span class="keywordflow">if</span> (ref-&gt;<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) ref = &amp;<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>;

    <span class="keywordflow">if</span> ((ref-&gt;<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>() == destination) || (test == *ref)) {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordtype">bool</span> closer = <span class="keyword">false</span>;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* refDist = <a class="code" href="classPastryStateObject.html#a182dd91bf8a093548c63b3a48caf558e" title="compute the distance of two keys on the ring">keyDist</a>(ref-&gt;<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>(), destination);
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* testDist = <a class="code" href="classPastryStateObject.html#a182dd91bf8a093548c63b3a48caf558e" title="compute the distance of two keys on the ring">keyDist</a>(test.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>(), destination);
    <span class="keywordflow">if</span> (*testDist &lt; *refDist)
        closer = <span class="keyword">true</span>;
    <span class="keyword">delete</span> refDist;
    <span class="keyword">delete</span> testDist;
    <span class="keywordflow">return</span> closer;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a182dd91bf8a093548c63b3a48caf558e"></a><!-- doxytag: member="PastryStateObject::keyDist" ref="a182dd91bf8a093548c63b3a48caf558e" args="(const OverlayKey &amp;a, const OverlayKey &amp;b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOverlayKey.html">OverlayKey</a> * PastryStateObject::keyDist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compute the distance of two keys on the ring </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>one key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>another key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to distance (must be deleted by caller) </dd></dl>

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00107">107</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryStateObject_8cc_source.html#l00134">isCloser()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* smaller;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* bigger;

    <span class="keywordflow">if</span> (a &gt; b) {
        smaller = &amp;b;
        bigger = &amp;a;
    } <span class="keywordflow">else</span> {
        smaller = &amp;a;
        bigger = &amp;b;
    }

    <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> diff1(*bigger - *smaller);
    <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> diff2(*smaller + (<a class="code" href="classOverlayKey.html#a6434b4360f6feec10578daa85001f6c1" title="Returns the maximum key, i.e.">OverlayKey::getMax</a>() - *bigger) + 1);

    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* dist;
    <span class="keywordflow">if</span> (diff1 &gt; diff2) {
        dist = <span class="keyword">new</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>(diff2);
    } <span class="keywordflow">else</span> {
        dist = <span class="keyword">new</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>(diff1);
    }

    <span class="keywordflow">return</span> dist;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa5029ce2c80ae1a744ea92efc02dc8a7"></a><!-- doxytag: member="PastryStateObject::mergeNode" ref="aa5029ce2c80ae1a744ea92efc02dc8a7" args="(const NodeHandle &amp;node, simtime_t prox)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PastryStateObject::mergeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>prox</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>try to merge a single node in the state table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>handle of the node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prox</em>&nbsp;</td><td>proximity value of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if node was inserted </dd></dl>

<p>Implemented in <a class="el" href="classPastryLeafSet.html#a1e19ba86f8c54fdab06a8aed85a8c95f">PastryLeafSet</a>, <a class="el" href="classPastryNeighborhoodSet.html#a1aa8142a891251518109a700377d1458">PastryNeighborhoodSet</a>, and <a class="el" href="classPastryRoutingTable.html#a92eb6e9176f873cb0a7106ce6e97a53e">PastryRoutingTable</a>.</p>

<p>Referenced by <a class="el" href="PastryStateObject_8cc_source.html#l00061">mergeState()</a>.</p>

</div>
</div>
<a class="anchor" id="a36f82233ec05837bf3761057f2437c86"></a><!-- doxytag: member="PastryStateObject::mergeState" ref="a36f82233ec05837bf3761057f2437c86" args="(const PastryStateMessage *msg, const PastryStateMsgProximity *prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryStateObject::mergeState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *&nbsp;</td>
          <td class="paramname"> <em>prox</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>update own state based on a received <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>the <a class="el" href="classPastryStateMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryStateMessage</a> to use as source for update </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prox</em>&nbsp;</td><td>record of proximity values matching the state message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if leafSet was actually changed </dd></dl>

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00061">61</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00765">Pastry::checkProxCache()</a>, <a class="el" href="Bamboo_8cc_source.html#l00432">Bamboo::checkProxCache()</a>, <a class="el" href="Pastry_8cc_source.html#l01071">Pastry::handleStateMessage()</a>, <a class="el" href="Bamboo_8cc_source.html#l00481">Bamboo::handleStateMessage()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00327">PastryRoutingTable::initStateFromHandleVector()</a>, <a class="el" href="Pastry_8cc_source.html#l00975">Pastry::mergeState()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00411">PastryRoutingTable::repair()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00537">PastryLeafSet::repair()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
    <span class="keywordtype">int</span> lsSize = msg-&gt;<a class="code" href="classPastryStateMessage.html#ad792f9b41aee54969504dee46452252c">getLeafSetArraySize</a>();
    <span class="keywordtype">int</span> rtSize = msg-&gt;<a class="code" href="classPastryStateMessage.html#a2abf365a56348d30b99e9733c6905065">getRoutingTableArraySize</a>();
    <span class="keywordtype">int</span> nsSize = msg-&gt;<a class="code" href="classPastryStateMessage.html#a88929cf3d5340cda73e6305c25714788">getNeighborhoodSetArraySize</a>();
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* node;
    simtime_t rtt;

    <span class="comment">// walk through msg&#39;s LeafSet</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lsSize; i++) {
        node = &amp;(msg-&gt;<a class="code" href="classPastryStateMessage.html#a27c65fc289c9baa8121a8be1977839cd">getLeafSet</a>(i));
        rtt = prox ? (*(prox-&gt;<a class="code" href="structPastryStateMsgProximity.html#adbadfcad7fd962f6b3a12c003f873dfb">pr_ls</a>.begin() + i)) : SimTime::getMaxTime();

        <span class="comment">// unspecified nodes, own node and dead nodes not considered</span>
        <span class="keywordflow">if</span> (!(rtt &lt; 0 || node-&gt;isUnspecified() || *node == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>)) {
            <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7" title="try to merge a single node in the state table">mergeNode</a>(*node, rtt)) ret = <span class="keyword">true</span>;
        }
    }

    <span class="comment">// walk through msg&#39;s IRoutingTable</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rtSize; i++) {
        node = &amp;(msg-&gt;<a class="code" href="classPastryStateMessage.html#a0e4a031d7e3a30bd94c3867d0862288e">getRoutingTable</a>(i));
        rtt = prox ? (*(prox-&gt;<a class="code" href="structPastryStateMsgProximity.html#afc10e12f0e7f2806255ce8277ece0a62">pr_rt</a>.begin() + i)) : SimTime::getMaxTime();

        <span class="comment">// unspecified nodes, own node and dead nodes not considered</span>
        <span class="keywordflow">if</span> (!(rtt &lt; 0 || node-&gt;isUnspecified() || *node == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>)) {
            <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7" title="try to merge a single node in the state table">mergeNode</a>(*node, rtt)) ret = <span class="keyword">true</span>;
        }
    }

    <span class="comment">// walk through msg&#39;s NeighborhoodSet</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nsSize; i++) {
        node = &amp;(msg-&gt;<a class="code" href="classPastryStateMessage.html#a359b5a6fff11286993c16b9eec3da15a">getNeighborhoodSet</a>(i));
        rtt = prox ? (*(prox-&gt;<a class="code" href="structPastryStateMsgProximity.html#a564d4bd5da4adead22fc4ef02d9c1c91">pr_ns</a>.begin() + i)) : SimTime::getMaxTime();

        <span class="comment">// unspecified nodes, own node and dead nodes not considered</span>
        <span class="keywordflow">if</span> (!(rtt &lt; 0 || node-&gt;isUnspecified() || *node == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>)) {
            <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7" title="try to merge a single node in the state table">mergeNode</a>(*node, rtt)) ret = <span class="keyword">true</span>;
        }
    }

    <span class="keywordflow">return</span> ret;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab32d468bd497367a3f993fd90de46982"></a><!-- doxytag: member="PastryStateObject::numInitStages" ref="ab32d468bd497367a3f993fd90de46982" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PastryStateObject::numInitStages </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00031">31</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> MAX_STAGE_OVERLAY;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a70220d25c9d51c068189884d973f45dc"></a><!-- doxytag: member="PastryStateObject::repair" ref="a70220d25c9d51c068189884d973f45dc" args="(const PastryStateMessage *msg, const PastryStateMsgProximity &amp;prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryStateObject::repair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prox</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>attempt to repair state using a received REPAIR message </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>the state message of type REPAIR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prox</em>&nbsp;</td><td>record of proximity values matching the state message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>another node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00054">54</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a13a6c5fdcbe191dc45619aeaa29f1993"></a><!-- doxytag: member="PastryStateObject::specialCloserCondition" ref="a13a6c5fdcbe191dc45619aeaa29f1993" args="(const NodeHandle &amp;test, const OverlayKey &amp;destination, const NodeHandle &amp;reference=NodeHandle::UNSPECIFIED_NODE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryStateObject::specialCloserCondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>reference</em> = <code><a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6">NodeHandle::UNSPECIFIED_NODE</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test a given <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> if it is closer to a given destination, but only if the shared prefix length with the destination is at least equal to the shared prefix length with our own node </p>
<p>This is needed for the "rare case" in the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>the destination Key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reference</em>&nbsp;</td><td><a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> to compare to, own node if unset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if test is closer to destination than owner </dd></dl>

<p>Definition at line <a class="el" href="PastryStateObject_8cc_source.html#l00157">157</a> of file <a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00088">PastryRoutingTable::findCloserNode()</a>, <a class="el" href="PastryNeighborhoodSet_8cc_source.html#l00064">PastryNeighborhoodSet::findCloserNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00458">PastryLeafSet::findCloserNode()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
<span class="comment">//    std::cout &lt;&lt; ((test.getKey().sharedPrefixLength(destination, bitsPerDigit)</span>
<span class="comment">//                  &lt; owner.getKey().sharedPrefixLength(destination, bitsPerDigit))</span>
<span class="comment">//                  != (test.getKey().sharedPrefixLength(destination)</span>
<span class="comment">//                      &lt; owner.getKey().sharedPrefixLength(destination)) ? &quot;X\n&quot; : &quot;&quot;);</span>

    <span class="keywordflow">if</span> (test.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(destination, <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>)
            &lt; <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(destination, <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>)) {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">return</span> <a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(test, destination, reference);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a957e9ac8870e9f03df83f85ff4d8cf7b"></a><!-- doxytag: member="PastryStateObject::unspecNode" ref="a957e9ac8870e9f03df83f85ff4d8cf7b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structPastryExtendedNode.html">PastryExtendedNode</a>&amp; PastryStateObject::unspecNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryStateObject_8h_source.html#l00174">174</a> of file <a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00351">PastryRoutingTable::addRow()</a>, <a class="el" href="PastryNeighborhoodSet_8cc_source.html#l00137">PastryNeighborhoodSet::failedNode()</a>, <a class="el" href="PastryNeighborhoodSet_8cc_source.html#l00034">PastryNeighborhoodSet::initializeSet()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00058">PastryRoutingTable::nodeAt()</a>.</p>

<p><div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#a828ca53b6489299c05fcc898cdd185c5" title="unspecified Node with proximity">_unspecNode</a> == NULL)
            <a class="code" href="classPastryStateObject.html#a828ca53b6489299c05fcc898cdd185c5" title="unspecified Node with proximity">_unspecNode</a> = <span class="keyword">new</span> <a class="code" href="structPastryExtendedNode.html" title="struct for storing a NodeHandle together with its proximity value and an optional timestamp...">PastryExtendedNode</a>();
        <span class="keywordflow">return</span> *<a class="code" href="classPastryStateObject.html#a828ca53b6489299c05fcc898cdd185c5" title="unspecified Node with proximity">_unspecNode</a>;
    }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a828ca53b6489299c05fcc898cdd185c5"></a><!-- doxytag: member="PastryStateObject::_unspecNode" ref="a828ca53b6489299c05fcc898cdd185c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structPastryExtendedNode.html">PastryExtendedNode</a> * <a class="el" href="classPastryStateObject.html#a828ca53b6489299c05fcc898cdd185c5">PastryStateObject::_unspecNode</a> = NULL<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unspecified Node with proximity </p>

<p>Definition at line <a class="el" href="PastryStateObject_8h_source.html#l00171">171</a> of file <a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a>.</p>

<p>Referenced by <a class="el" href="PastryStateObject_8h_source.html#l00174">unspecNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a755bc90b0fb6bd61c42207d17855b743"></a><!-- doxytag: member="PastryStateObject::bitsPerDigit" ref="a755bc90b0fb6bd61c42207d17855b743" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">PastryStateObject::bitsPerDigit</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryStateObject_8h_source.html#l00165">165</a> of file <a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00028">PastryRoutingTable::digitAt()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00088">PastryRoutingTable::findCloserNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00066">PastryRoutingTable::lookupNextHop()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00296">PastryRoutingTable::mergeNode()</a>, and <a class="el" href="PastryStateObject_8cc_source.html#l00157">specialCloserCondition()</a>.</p>

</div>
</div>
<a class="anchor" id="a946cabf3c3e981122e05bb37bf1c95dc"></a><!-- doxytag: member="PastryStateObject::owner" ref="a946cabf3c3e981122e05bb37bf1c95dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNodeHandle.html">NodeHandle</a> <a class="el" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc">PastryStateObject::owner</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>stores the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of the owner of this <a class="el" href="classPastryStateObject.html" title="PastryStateObject Module.">PastryStateObject</a>. </p>
<p>Derived classes have to initialize it. </p>

<p>Definition at line <a class="el" href="PastryStateObject_8h_source.html#l00163">163</a> of file <a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00351">PastryRoutingTable::addRow()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00220">PastryLeafSet::createSiblingVector()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00088">PastryRoutingTable::findCloserNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00459">PastryRoutingTable::findNextNodeToAsk()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00106">PastryLeafSet::getDestinationNode()</a>, <a class="el" href="PastryStateObject_8cc_source.html#l00134">isCloser()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00136">PastryLeafSet::isClosestNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00066">PastryRoutingTable::lookupNextHop()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00296">PastryRoutingTable::mergeNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00261">PastryLeafSet::mergeNode()</a>, <a class="el" href="PastryStateObject_8cc_source.html#l00061">mergeState()</a>, and <a class="el" href="PastryStateObject_8cc_source.html#l00157">specialCloserCondition()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="PastryStateObject_8h_source.html">PastryStateObject.h</a></li>
<li><a class="el" href="PastryStateObject_8cc_source.html">PastryStateObject.cc</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 3 2010 14:40:53 for OverSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
