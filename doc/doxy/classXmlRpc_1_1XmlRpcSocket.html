<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: XmlRpc::XmlRpcSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceXmlRpc.html">XmlRpc</a>      </li>
      <li><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html">XmlRpc::XmlRpcSocket</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>XmlRpc::XmlRpcSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="XmlRpc::XmlRpcSocket" -->
<p>A platform-independent socket API.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="XmlRpcSocket_8h_source.html">XmlRpcSocket.h</a>&gt;</code></p>

<p><a href="classXmlRpc_1_1XmlRpcSocket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a3c69282c6c7cfbdcb8afc90c178c2cf1">getSocket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a stream (TCP) socket. Returns -1 on failure.  <a href="#a3c69282c6c7cfbdcb8afc90c178c2cf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#ac5c50e12ee428f4190a81a38d196bd70">close</a> (int socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a socket.  <a href="#ac5c50e12ee428f4190a81a38d196bd70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#abc6fc4083d79a873bdeab20ae09ab549">setNonBlocking</a> (int socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a stream (TCP) socket to perform non-blocking IO. Returns false on failure.  <a href="#abc6fc4083d79a873bdeab20ae09ab549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a6444e46abadd7b59cea079e3a25fc87b">nbRead</a> (int socket, std::string &amp;s, bool *eof, SSL *ssl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read text from the specified socket. Returns false on error.  <a href="#a6444e46abadd7b59cea079e3a25fc87b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a878097ad3bcce2f7046e30322b5ac7ef">nbWrite</a> (int socket, std::string &amp;s, int *bytesSoFar, SSL *ssl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write text to the specified socket. Returns false on error.  <a href="#a878097ad3bcce2f7046e30322b5ac7ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a8a98b18862a7b79e82ee608484a1a460">setReuseAddr</a> (int socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow the port the specified socket is bound to to be re-bound immediately so server re-starts are not delayed.  <a href="#a8a98b18862a7b79e82ee608484a1a460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#ad7bcf641b1e2e5857ee3b7f57439b959">bind</a> (int socket, int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to a specified port.  <a href="#ad7bcf641b1e2e5857ee3b7f57439b959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a3fe3ac75b1d632b94f233d743cc2bed5">listen</a> (int socket, int backlog)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket in listen mode.  <a href="#a3fe3ac75b1d632b94f233d743cc2bed5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a653b1f5a5eb6991d69fdb405100fc170">accept</a> (int socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a client connection request.  <a href="#a653b1f5a5eb6991d69fdb405100fc170"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a9eef45df476437a085a1ab8be744cfc6">connect</a> (int socket, std::string &amp;host, int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect a socket to a server (from a client).  <a href="#a9eef45df476437a085a1ab8be744cfc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#ac8ab6d64cc27452547a40ac73381737d">getPort</a> (int socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classGet.html">Get</a> the port of a bound socket.  <a href="#ac8ab6d64cc27452547a40ac73381737d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14">nonFatalError</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the last error was not a fatal one (eg, EWOULDBLOCK).  <a href="#ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a4953010f3d84287639b3fd73ff29a682">getError</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns last errno.  <a href="#a4953010f3d84287639b3fd73ff29a682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#ae1926209b963e3e1a95a41fd25dcd43d">getErrorMsg</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns message corresponding to last error.  <a href="#ae1926209b963e3e1a95a41fd25dcd43d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcSocket.html#a2f9e8645065a252d36a0b83964ff61a3">getErrorMsg</a> (int error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns message corresponding to error.  <a href="#a2f9e8645065a252d36a0b83964ff61a3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A platform-independent socket API. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8h_source.html#l00031">31</a> of file <a class="el" href="XmlRpcSocket_8h_source.html">XmlRpcSocket.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a653b1f5a5eb6991d69fdb405100fc170"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::accept" ref="a653b1f5a5eb6991d69fdb405100fc170" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XmlRpcSocket::accept </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept a client connection request. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00142">142</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00175">XmlRpc::XmlRpcServer::acceptConnection()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keyword">struct </span>sockaddr_in addr;
  socklen_t addrlen = <span class="keyword">sizeof</span>(addr);

  <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#a653b1f5a5eb6991d69fdb405100fc170" title="Accept a client connection request."> ::accept</a>(fd, (<span class="keyword">struct </span>sockaddr*)&amp;addr, &amp;addrlen);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad7bcf641b1e2e5857ee3b7f57439b959"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::bind" ref="ad7bcf641b1e2e5857ee3b7f57439b959" args="(int socket, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::bind </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind to a specified port. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00122">122</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keyword">struct </span>sockaddr_in saddr;
  memset(&amp;saddr, 0, <span class="keyword">sizeof</span>(saddr));
  saddr.sin_family = AF_INET;
  saddr.sin_addr.s_addr = htonl(INADDR_ANY);
  saddr.sin_port = htons((u_short) port);
  <span class="keywordflow">return</span> (::<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#ad7bcf641b1e2e5857ee3b7f57439b959" title="Bind to a specified port.">bind</a>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) == 0);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5c50e12ee428f4190a81a38d196bd70"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::close" ref="ac5c50e12ee428f4190a81a38d196bd70" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XmlRpcSocket::close </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a socket. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00086">86</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <a class="code" href="classXmlRpc_1_1XmlRpcUtil.html#ac8423b781acbcbf90e5d4558591e7c61" title="Dump messages somewhere.">XmlRpcUtil::log</a>(4, <span class="stringliteral">&quot;XmlRpcSocket::close: fd %d.&quot;</span>, fd);
<span class="preprocessor">#if defined(_WINDOWS)</span>
<span class="preprocessor"></span>  closesocket(fd);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#ac5c50e12ee428f4190a81a38d196bd70" title="Closes a socket.">  ::close</a>(fd);
<span class="preprocessor">#endif // _WINDOWS</span>
<span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9eef45df476437a085a1ab8be744cfc6"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::connect" ref="a9eef45df476437a085a1ab8be744cfc6" args="(int socket, std::string &amp;host, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::connect </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect a socket to a server (from a client). </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00154">154</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcClient_8cc_source.html#l00267">XmlRpc::XmlRpcClient::doConnect()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keyword">struct </span>sockaddr_in saddr;
  memset(&amp;saddr, 0, <span class="keyword">sizeof</span>(saddr));
  saddr.sin_family = AF_INET;

  <span class="keyword">struct </span>hostent *hp = gethostbyname(host.c_str());
  <span class="keywordflow">if</span> (hp == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;

  saddr.sin_family = hp-&gt;h_addrtype;
  memcpy(&amp;saddr.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
  saddr.sin_port = htons((u_short) port);

  <span class="comment">// For asynch operation, this will return EWOULDBLOCK (windows) or</span>
  <span class="comment">// EINPROGRESS (linux) and we just need to wait for the socket to be writable...</span>
  <span class="keywordtype">int</span> result =<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#a9eef45df476437a085a1ab8be744cfc6" title="Connect a socket to a server (from a client)."> ::connect</a>(fd, (<span class="keyword">struct </span>sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));
  <span class="keywordflow">return</span> result == 0 || <a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14" title="Returns true if the last error was not a fatal one (eg, EWOULDBLOCK).">nonFatalError</a>();
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4953010f3d84287639b3fd73ff29a682"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::getError" ref="a4953010f3d84287639b3fd73ff29a682" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XmlRpcSocket::getError </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns last errno. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00272">272</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcSocket_8cc_source.html#l00284">getErrorMsg()</a>, and <a class="el" href="XmlRpcSocket_8cc_source.html#l00070">nonFatalError()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
<span class="preprocessor">#if defined(_WINDOWS)</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> WSAGetLastError();
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> errno;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2f9e8645065a252d36a0b83964ff61a3"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::getErrorMsg" ref="a2f9e8645065a252d36a0b83964ff61a3" args="(int error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XmlRpcSocket::getErrorMsg </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>error</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns message corresponding to error. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00291">291</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">char</span> err[60];
  snprintf(err,<span class="keyword">sizeof</span>(err),<span class="stringliteral">&quot;error %d&quot;</span>, <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>);
  <span class="keywordflow">return</span> std::string(err);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae1926209b963e3e1a95a41fd25dcd43d"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::getErrorMsg" ref="ae1926209b963e3e1a95a41fd25dcd43d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XmlRpcSocket::getErrorMsg </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns message corresponding to last error. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00284">284</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00175">XmlRpc::XmlRpcServer::acceptConnection()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00267">XmlRpc::XmlRpcClient::doConnect()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00208">XmlRpc::XmlRpcClient::handleEvent()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00066">XmlRpc::XmlRpcServerConnection::readHeader()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00426">XmlRpc::XmlRpcClient::readHeader()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00145">XmlRpc::XmlRpcServerConnection::readRequest()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00497">XmlRpc::XmlRpcClient::readResponse()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00401">XmlRpc::XmlRpcClient::writeRequest()</a>, and <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00177">XmlRpc::XmlRpcServerConnection::writeResponse()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#ae1926209b963e3e1a95a41fd25dcd43d" title="Returns message corresponding to last error.">getErrorMsg</a>(<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#a4953010f3d84287639b3fd73ff29a682" title="Returns last errno.">getError</a>());
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac8ab6d64cc27452547a40ac73381737d"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::getPort" ref="ac8ab6d64cc27452547a40ac73381737d" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XmlRpcSocket::getPort </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classGet.html">Get</a> the port of a bound socket. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00253">253</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keyword">struct </span>sockaddr_in saddr;
  socklen_t saddr_len = <span class="keyword">sizeof</span>(saddr);
  <span class="keywordtype">int</span> port;

  <span class="keywordtype">int</span> result = ::getsockname(socket, (sockaddr*) &amp;saddr, &amp;saddr_len);

  <span class="keywordflow">if</span> (result != 0) {
    port = -1;
  } <span class="keywordflow">else</span> {
    port = ntohs(saddr.sin_port);
  }
  <span class="keywordflow">return</span> port;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3c69282c6c7cfbdcb8afc90c178c2cf1"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::getSocket" ref="a3c69282c6c7cfbdcb8afc90c178c2cf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XmlRpcSocket::getSocket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a stream (TCP) socket. Returns -1 on failure. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00078">78</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>, and <a class="el" href="XmlRpcClient_8cc_source.html#l00267">XmlRpc::XmlRpcClient::doConnect()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <a class="code" href="XmlRpcSocket_8cc.html#ae011cdcec15e81d8d2e14cd386debf32">initWinSock</a>();
  <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) ::socket(AF_INET, SOCK_STREAM, 0);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3fe3ac75b1d632b94f233d743cc2bed5"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::listen" ref="a3fe3ac75b1d632b94f233d743cc2bed5" args="(int socket, int backlog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::listen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set socket in listen mode. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00135">135</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (::<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#a3fe3ac75b1d632b94f233d743cc2bed5" title="Set socket in listen mode.">listen</a>(fd, backlog) == 0);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6444e46abadd7b59cea079e3a25fc87b"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::nbRead" ref="a6444e46abadd7b59cea079e3a25fc87b" args="(int socket, std::string &amp;s, bool *eof, SSL *ssl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::nbRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SSL *&nbsp;</td>
          <td class="paramname"> <em>ssl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read text from the specified socket. Returns false on error. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00177">177</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00066">XmlRpc::XmlRpcServerConnection::readHeader()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00426">XmlRpc::XmlRpcClient::readHeader()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00145">XmlRpc::XmlRpcServerConnection::readRequest()</a>, and <a class="el" href="XmlRpcClient_8cc_source.html#l00497">XmlRpc::XmlRpcClient::readResponse()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> READ_SIZE = 4096;   <span class="comment">// Number of bytes to attempt to read at a time</span>
  <span class="keywordtype">char</span> readBuf[READ_SIZE];

  <span class="keywordtype">bool</span> wouldBlock = <span class="keyword">false</span>;
  *eof = <span class="keyword">false</span>;

  <span class="keywordflow">while</span> ( ! wouldBlock &amp;&amp; ! *eof) {
<span class="preprocessor">#if defined(_WINDOWS)</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> n = recv(fd, readBuf, READ_SIZE-1, 0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> n = 0;
    <span class="keywordflow">if</span> (ssl != (<a class="code" href="XmlRpcSocket_8h.html#adc3d9d4ae62abe565893e214a6e6401e">SSL</a> *) NULL) {
<span class="preprocessor">#ifdef USE_SSL</span>
<span class="preprocessor"></span>      n = <a class="code" href="XmlRpcSocket_8h.html#aae68723650f0ed53b36894d426afdbc9">SSL_read</a>(ssl, readBuf, READ_SIZE-1);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
      n = read(fd, readBuf, READ_SIZE-1);
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <a class="code" href="classXmlRpc_1_1XmlRpcUtil.html#ac8423b781acbcbf90e5d4558591e7c61" title="Dump messages somewhere.">XmlRpcUtil::log</a>(5, <span class="stringliteral">&quot;XmlRpcSocket::nbRead: read/recv returned %d.&quot;</span>, n);

    <span class="keywordflow">if</span> (n &gt; 0) {
      readBuf[n] = 0;
      s.append(readBuf, n);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 0) {
      *eof = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14" title="Returns true if the last error was not a fatal one (eg, EWOULDBLOCK).">nonFatalError</a>()) {
      wouldBlock = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
      <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// Error</span>
    }
  }
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a878097ad3bcce2f7046e30322b5ac7ef"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::nbWrite" ref="a878097ad3bcce2f7046e30322b5ac7ef" args="(int socket, std::string &amp;s, int *bytesSoFar, SSL *ssl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::nbWrite </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bytesSoFar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SSL *&nbsp;</td>
          <td class="paramname"> <em>ssl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write text to the specified socket. Returns false on error. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00217">217</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcClient_8cc_source.html#l00401">XmlRpc::XmlRpcClient::writeRequest()</a>, and <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00177">XmlRpc::XmlRpcServerConnection::writeResponse()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> nToWrite = int(s.length()) - *bytesSoFar;
  <span class="keywordtype">char</span> *sp = <span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(s.c_str()) + *bytesSoFar;
  <span class="keywordtype">bool</span> wouldBlock = <span class="keyword">false</span>;

  <span class="keywordflow">while</span> ( nToWrite &gt; 0 &amp;&amp; ! wouldBlock ) {
<span class="preprocessor">#if defined(_WINDOWS)</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> n = send(fd, sp, nToWrite, 0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> n = 0;
    <span class="keywordflow">if</span> (ssl != (<a class="code" href="XmlRpcSocket_8h.html#adc3d9d4ae62abe565893e214a6e6401e">SSL</a> *) NULL) {
<span class="preprocessor">#ifdef USE_SSL</span>
<span class="preprocessor"></span>      n = <a class="code" href="XmlRpcSocket_8h.html#a7ca4a51d411e5c43e3b6e57b8ea19f2c">SSL_write</a>(ssl, sp, nToWrite);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
      n = write(fd, sp, nToWrite);
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <a class="code" href="classXmlRpc_1_1XmlRpcUtil.html#ac8423b781acbcbf90e5d4558591e7c61" title="Dump messages somewhere.">XmlRpcUtil::log</a>(5, <span class="stringliteral">&quot;XmlRpcSocket::nbWrite: send/write returned %d.&quot;</span>, n);

    <span class="keywordflow">if</span> (n &gt; 0) {
      sp += n;
      *bytesSoFar += n;
      nToWrite -= n;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14" title="Returns true if the last error was not a fatal one (eg, EWOULDBLOCK).">nonFatalError</a>()) {
      wouldBlock = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
      <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// Error</span>
    }
  }
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::nonFatalError" ref="ab77fa1a5bdf9ae4c8f7cfd9f5cf21f14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::nonFatalError </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the last error was not a fatal one (eg, EWOULDBLOCK). </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00070">70</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcSocket_8cc_source.html#l00154">connect()</a>, <a class="el" href="XmlRpcSocket_8cc_source.html#l00177">nbRead()</a>, and <a class="el" href="XmlRpcSocket_8cc_source.html#l00217">nbWrite()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> err = <a class="code" href="classXmlRpc_1_1XmlRpcSocket.html#a4953010f3d84287639b3fd73ff29a682" title="Returns last errno.">XmlRpcSocket::getError</a>();
  <span class="keywordflow">return</span> (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="abc6fc4083d79a873bdeab20ae09ab549"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::setNonBlocking" ref="abc6fc4083d79a873bdeab20ae09ab549" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::setNonBlocking </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a stream (TCP) socket to perform non-blocking IO. Returns false on failure. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00100">100</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00175">XmlRpc::XmlRpcServer::acceptConnection()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>, and <a class="el" href="XmlRpcClient_8cc_source.html#l00267">XmlRpc::XmlRpcClient::doConnect()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
<span class="preprocessor">#if defined(_WINDOWS)</span>
<span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flag = 1;
  <span class="keywordflow">return</span> (ioctlsocket((SOCKET)fd, FIONBIO, &amp;flag) == 0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> (fcntl(fd, F_SETFL, O_NONBLOCK) == 0);
<span class="preprocessor">#endif // _WINDOWS</span>
<span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8a98b18862a7b79e82ee608484a1a460"></a><!-- doxytag: member="XmlRpc::XmlRpcSocket::setReuseAddr" ref="a8a98b18862a7b79e82ee608484a1a460" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcSocket::setReuseAddr </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allow the port the specified socket is bound to to be re-bound immediately so server re-starts are not delayed. </p>
<p>Returns false on failure. </p>

<p>Definition at line <a class="el" href="XmlRpcSocket_8cc_source.html#l00112">112</a> of file <a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="comment">// Allow this port to be re-bound immediately so server re-starts are not delayed</span>
  <span class="keywordtype">int</span> sflag = 1;
  <span class="keywordflow">return</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;sflag, <span class="keyword">sizeof</span>(sflag)) == 0);
}
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="XmlRpcSocket_8h_source.html">XmlRpcSocket.h</a></li>
<li><a class="el" href="XmlRpcSocket_8cc_source.html">XmlRpcSocket.cc</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 3 2010 14:40:56 for OverSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
