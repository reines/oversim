<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: hashWatch.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_668dee661430860db5868c2621a9c372.html">src</a>      </li>
      <li><a class="el" href="dir_c6e45067cd9ed30d67160903d22a8d0a.html">common</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>hashWatch.h</h1>  </div>
</div>
<div class="contents">
<a href="hashWatch_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">// Copyright (C) 2006 Institut fuer Telematik, Universitaet Karlsruhe (TH)</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// This program is free software; you can redistribute it and/or</span>
<a name="l00005"></a>00005 <span class="comment">// modify it under the terms of the GNU General Public License</span>
<a name="l00006"></a>00006 <span class="comment">// as published by the Free Software Foundation; either version 2</span>
<a name="l00007"></a>00007 <span class="comment">// of the License, or (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 
<a name="l00024"></a>00024 <span class="preprocessor">#ifndef __WATCHABLECONTAINERS_H__</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#define __WATCHABLECONTAINERS_H__</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;omnetpp.h&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;deque&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="oversim__mapset_8h.html">oversim_mapset.h</a>&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00034"></a><a class="code" href="classcHashSetWatcher.html">00034</a> <span class="keyword">class </span>SIM_API <a class="code" href="classcHashSetWatcher.html">cHashSetWatcher</a> : <span class="keyword">public</span> cStdVectorWatcherBase
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036     <span class="keyword">protected</span>:
<a name="l00037"></a><a class="code" href="classcHashSetWatcher.html#a84e7a36a7435dc8ce061eb7e65ee8c7d">00037</a>         UNORDERED_SET&lt;T&gt;&amp; v;
<a name="l00038"></a><a class="code" href="classcHashSetWatcher.html#a8c91b12a7b86d640ce257faaa7896c1b">00038</a>         std::string classname;
<a name="l00039"></a><a class="code" href="classcHashSetWatcher.html#a4234e62cef381692c24c1cb2a25aa157">00039</a>         <span class="keyword">mutable</span> <span class="keyword">typename</span> UNORDERED_SET&lt;T&gt;::iterator it;
<a name="l00040"></a><a class="code" href="classcHashSetWatcher.html#aaf231dc74e6d18c29ec52200981ff127">00040</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> itPos;
<a name="l00041"></a>00041     <span class="keyword">public</span>:
<a name="l00042"></a><a class="code" href="classcHashSetWatcher.html#ac4e2d26db71e5b25eb6eec573cc20e5a">00042</a>         <a class="code" href="classcHashSetWatcher.html#ac4e2d26db71e5b25eb6eec573cc20e5a">cHashSetWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, UNORDERED_SET&lt;T&gt;&amp; var) : cStdVectorWatcherBase(name), v(var) {
<a name="l00043"></a>00043             itPos=-1;
<a name="l00044"></a>00044             classname = std::string(<span class="stringliteral">&quot;unordered_set&lt;&quot;</span>)+opp_typename(<span class="keyword">typeid</span>(T))+<span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l00045"></a>00045         }
<a name="l00046"></a><a class="code" href="classcHashSetWatcher.html#aadc492c7133d196da6d141deee3c3327">00046</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcHashSetWatcher.html#aadc492c7133d196da6d141deee3c3327">getClassName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> classname.c_str();}
<a name="l00047"></a><a class="code" href="classcHashSetWatcher.html#a7efa4696f42753663f909c72afc0e866">00047</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcHashSetWatcher.html#a7efa4696f42753663f909c72afc0e866">getElemTypeName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> opp_typename(<span class="keyword">typeid</span>(T));}
<a name="l00048"></a><a class="code" href="classcHashSetWatcher.html#a78644e5b5162fd8864441aafada0aaa3">00048</a>         <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcHashSetWatcher.html#a78644e5b5162fd8864441aafada0aaa3">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> v.size();}
<a name="l00049"></a><a class="code" href="classcHashSetWatcher.html#ac0cb394e5d91378ec1f7225c54dd60b9">00049</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcHashSetWatcher.html#ac0cb394e5d91378ec1f7225c54dd60b9">at</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l00050"></a>00050             <span class="keywordflow">if</span> (i==0) {
<a name="l00051"></a>00051                 it=v.begin(); itPos=0;
<a name="l00052"></a>00052             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==itPos+1 &amp;&amp; it!=v.end()) {
<a name="l00053"></a>00053                 ++it; ++itPos;
<a name="l00054"></a>00054             } <span class="keywordflow">else</span> {
<a name="l00055"></a>00055                 it=v.begin();
<a name="l00056"></a>00056                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i &amp;&amp; it!=v.end(); k++) ++it;
<a name="l00057"></a>00057                 itPos=i;
<a name="l00058"></a>00058             }
<a name="l00059"></a>00059             <span class="keywordflow">if</span> (it==v.end()) {
<a name="l00060"></a>00060                 <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;out of bounds&quot;</span>);
<a name="l00061"></a>00061             }
<a name="l00062"></a>00062             <span class="keywordflow">return</span> atIt();
<a name="l00063"></a>00063         }
<a name="l00064"></a><a class="code" href="classcHashSetWatcher.html#aba8cf939215aa7879a750575b514a4c1">00064</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcHashSetWatcher.html#aba8cf939215aa7879a750575b514a4c1">atIt</a>()<span class="keyword"> const </span>{
<a name="l00065"></a>00065             std::stringstream out;
<a name="l00066"></a>00066             out &lt;&lt; (*it);
<a name="l00067"></a>00067             <span class="keywordflow">return</span> out.str();
<a name="l00068"></a>00068         }
<a name="l00069"></a>00069 };
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00072"></a><a class="code" href="hashWatch_8h.html#ab416df7ac8ba9bd8c7a93a360216b980">00072</a> <span class="keywordtype">void</span> <a class="code" href="hashWatch_8h.html#ab416df7ac8ba9bd8c7a93a360216b980">createHashSetWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *varname, UNORDERED_SET&lt;T&gt;&amp; v)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074     <span class="keyword">new</span> <a class="code" href="classcHashSetWatcher.html">cHashSetWatcher&lt;T&gt;</a>(varname, v);
<a name="l00075"></a>00075 };
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00078"></a><a class="code" href="classcDequeWatcher.html">00078</a> <span class="keyword">class </span>SIM_API <a class="code" href="classcDequeWatcher.html">cDequeWatcher</a> : <span class="keyword">public</span> cStdVectorWatcherBase
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080     <span class="keyword">protected</span>:
<a name="l00081"></a><a class="code" href="classcDequeWatcher.html#a281884dbcbc5941e619cf20736262080">00081</a>         std::deque&lt;T&gt;&amp; v;
<a name="l00082"></a><a class="code" href="classcDequeWatcher.html#a5306f7c8a9d4718bd0d726f9927fe932">00082</a>         std::string classname;
<a name="l00083"></a><a class="code" href="classcDequeWatcher.html#aa9fd80d8c279d42a538b68c055f02a2a">00083</a>         <span class="keyword">mutable</span> <span class="keyword">typename</span> std::deque&lt;T&gt;::iterator it;
<a name="l00084"></a><a class="code" href="classcDequeWatcher.html#a6a9c7fba1c01b93c2ed8ba48cfd0e26f">00084</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> itPos;
<a name="l00085"></a>00085     <span class="keyword">public</span>:
<a name="l00086"></a><a class="code" href="classcDequeWatcher.html#ab5de20c0172c04838840cf5e8a71fd51">00086</a>         <a class="code" href="classcDequeWatcher.html#ab5de20c0172c04838840cf5e8a71fd51">cDequeWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, std::deque&lt;T&gt;&amp; var) : cStdVectorWatcherBase(name), v(var) {
<a name="l00087"></a>00087             itPos=-1;
<a name="l00088"></a>00088             classname = std::string(<span class="stringliteral">&quot;deque&lt;&quot;</span>)+opp_typename(<span class="keyword">typeid</span>(T))+<span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l00089"></a>00089         }
<a name="l00090"></a><a class="code" href="classcDequeWatcher.html#ad58d5a00e196a79362fad7b74daf18da">00090</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcDequeWatcher.html#ad58d5a00e196a79362fad7b74daf18da">className</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> classname.c_str();}
<a name="l00091"></a><a class="code" href="classcDequeWatcher.html#a0a77375a6add00ec4b406a90c4fb2b6a">00091</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcDequeWatcher.html#a0a77375a6add00ec4b406a90c4fb2b6a">getElemTypeName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> opp_typename(<span class="keyword">typeid</span>(T));}
<a name="l00092"></a><a class="code" href="classcDequeWatcher.html#ad3f689dd07126b498dd0bb874b73bbf9">00092</a>         <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcDequeWatcher.html#ad3f689dd07126b498dd0bb874b73bbf9">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> v.size();}
<a name="l00093"></a><a class="code" href="classcDequeWatcher.html#a3454d98fc7457962c1e9a3bfd93ddcb0">00093</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcDequeWatcher.html#a3454d98fc7457962c1e9a3bfd93ddcb0">at</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l00094"></a>00094             <span class="keywordflow">if</span> (i==0) {
<a name="l00095"></a>00095                 it=v.begin(); itPos=0;
<a name="l00096"></a>00096             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==itPos+1 &amp;&amp; it!=v.end()) {
<a name="l00097"></a>00097                 ++it; ++itPos;
<a name="l00098"></a>00098             } <span class="keywordflow">else</span> {
<a name="l00099"></a>00099                 it=v.begin();
<a name="l00100"></a>00100                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i &amp;&amp; it!=v.end(); k++) ++it;
<a name="l00101"></a>00101                 itPos=i;
<a name="l00102"></a>00102             }
<a name="l00103"></a>00103             <span class="keywordflow">if</span> (it==v.end()) {
<a name="l00104"></a>00104                 <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;out of bounds&quot;</span>);
<a name="l00105"></a>00105             }
<a name="l00106"></a>00106             <span class="keywordflow">return</span> atIt();
<a name="l00107"></a>00107         }
<a name="l00108"></a><a class="code" href="classcDequeWatcher.html#abcf70441deb29a58c186a795ecd815a9">00108</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcDequeWatcher.html#abcf70441deb29a58c186a795ecd815a9">atIt</a>()<span class="keyword"> const </span>{
<a name="l00109"></a>00109             std::stringstream out;
<a name="l00110"></a>00110             out &lt;&lt; (*it);
<a name="l00111"></a>00111             <span class="keywordflow">return</span> out.str();
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113 };
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00116"></a><a class="code" href="hashWatch_8h.html#af234c5b80c1fca371d46fdd0dc8a494c">00116</a> <span class="keywordtype">void</span> <a class="code" href="hashWatch_8h.html#af234c5b80c1fca371d46fdd0dc8a494c">createDequeWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *varname, std::deque&lt;T&gt;&amp; v)
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118     <span class="keyword">new</span> <a class="code" href="classcDequeWatcher.html">cDequeWatcher&lt;T&gt;</a>(varname, v);
<a name="l00119"></a>00119 };
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00122"></a><a class="code" href="classcHashMapWatcher.html">00122</a> <span class="keyword">class </span>SIM_API <a class="code" href="classcHashMapWatcher.html">cHashMapWatcher</a> : <span class="keyword">public</span> cStdVectorWatcherBase
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124     <span class="keyword">protected</span>:
<a name="l00125"></a><a class="code" href="classcHashMapWatcher.html#a001243591490a59bf14654e737193d84">00125</a>         UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;&amp; m;
<a name="l00126"></a><a class="code" href="classcHashMapWatcher.html#a28be7bb4840cc07902fa2786cb6ce3f4">00126</a>         <span class="keyword">mutable</span> <span class="keyword">typename</span> UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;::iterator it;
<a name="l00127"></a><a class="code" href="classcHashMapWatcher.html#af90855e9ac706d54c8855e805e33b4ea">00127</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> itPos;
<a name="l00128"></a><a class="code" href="classcHashMapWatcher.html#a1c7a416ecff00d19e2de21e7030cbe7c">00128</a>         std::string classname;
<a name="l00129"></a>00129     <span class="keyword">public</span>:
<a name="l00130"></a><a class="code" href="classcHashMapWatcher.html#aa7a2fdaeb3236dce06da84415d061bf4">00130</a>         <a class="code" href="classcHashMapWatcher.html#aa7a2fdaeb3236dce06da84415d061bf4">cHashMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;&amp; var) : cStdVectorWatcherBase(name), m(var) {
<a name="l00131"></a>00131             itPos=-1;
<a name="l00132"></a>00132             classname = std::string(<span class="stringliteral">&quot;unordered_map&lt;&quot;</span>)+opp_typename(<span class="keyword">typeid</span>(KeyT))+<span class="stringliteral">&quot;,&quot;</span>+opp_typename(<span class="keyword">typeid</span>(ValueT))+<span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l00133"></a>00133         }
<a name="l00134"></a><a class="code" href="classcHashMapWatcher.html#aa1cc9abf60a63c72c4d6d384f3e4448a">00134</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcHashMapWatcher.html#aa1cc9abf60a63c72c4d6d384f3e4448a">getClassName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> classname.c_str();}
<a name="l00135"></a><a class="code" href="classcHashMapWatcher.html#a2621e12700e6ca0069fb934de69f2367">00135</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcHashMapWatcher.html#a2621e12700e6ca0069fb934de69f2367">getElemTypeName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="stringliteral">&quot;struct pair&lt;*,*&gt;&quot;</span>;}
<a name="l00136"></a><a class="code" href="classcHashMapWatcher.html#a9ee66545a5ab6748406a19daa16c9a1c">00136</a>         <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcHashMapWatcher.html#a9ee66545a5ab6748406a19daa16c9a1c">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> m.size();}
<a name="l00137"></a><a class="code" href="classcHashMapWatcher.html#ac238081878cc7c1d1d56704cc116f699">00137</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcHashMapWatcher.html#ac238081878cc7c1d1d56704cc116f699">at</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l00138"></a>00138             <span class="keywordflow">if</span> (i==0) {
<a name="l00139"></a>00139                 it=m.begin(); itPos=0;
<a name="l00140"></a>00140             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==itPos+1 &amp;&amp; it!=m.end()) {
<a name="l00141"></a>00141                 ++it; ++itPos;
<a name="l00142"></a>00142             } <span class="keywordflow">else</span> {
<a name="l00143"></a>00143                 it=m.begin();
<a name="l00144"></a>00144                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i &amp;&amp; it!=m.end(); k++) ++it;
<a name="l00145"></a>00145                 itPos=i;
<a name="l00146"></a>00146             }
<a name="l00147"></a>00147             <span class="keywordflow">if</span> (it==m.end()) {
<a name="l00148"></a>00148                 <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;out of bounds&quot;</span>);
<a name="l00149"></a>00149             }
<a name="l00150"></a>00150             <span class="keywordflow">return</span> atIt();
<a name="l00151"></a>00151         }
<a name="l00152"></a><a class="code" href="classcHashMapWatcher.html#a90287dccc76653256b0bfc89a5e5e6d4">00152</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcHashMapWatcher.html#a90287dccc76653256b0bfc89a5e5e6d4">atIt</a>()<span class="keyword"> const </span>{
<a name="l00153"></a>00153             std::stringstream out;
<a name="l00154"></a>00154             out &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot; ==&gt; &quot;</span> &lt;&lt; it-&gt;second;
<a name="l00155"></a>00155             <span class="keywordflow">return</span> out.str();
<a name="l00156"></a>00156         }
<a name="l00157"></a>00157 };
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00160"></a><a class="code" href="hashWatch_8h.html#a31110eab64ba991374c69abcf8e17ba2">00160</a> <span class="keywordtype">void</span> <a class="code" href="hashWatch_8h.html#a31110eab64ba991374c69abcf8e17ba2">createHashMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *varname, UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;&amp; m)
<a name="l00161"></a>00161 {
<a name="l00162"></a>00162     <span class="keyword">new</span> <a class="code" href="classcHashMapWatcher.html">cHashMapWatcher&lt;KeyT,ValueT,CmpT&gt;</a>(varname, m);
<a name="l00163"></a>00163 };
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00166"></a><a class="code" href="classcConstHashMapWatcher.html">00166</a> <span class="keyword">class </span>SIM_API <a class="code" href="classcConstHashMapWatcher.html">cConstHashMapWatcher</a> : <span class="keyword">public</span> cStdVectorWatcherBase
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168     <span class="keyword">protected</span>:
<a name="l00169"></a><a class="code" href="classcConstHashMapWatcher.html#a62974702feba12526286ca54c3482377">00169</a>         <span class="keyword">const</span> UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;&amp; m;
<a name="l00170"></a><a class="code" href="classcConstHashMapWatcher.html#a40cdca2c97c94bea104326d14387c155">00170</a>         <span class="keyword">mutable</span> <span class="keyword">typename</span> UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;::const_iterator it;
<a name="l00171"></a><a class="code" href="classcConstHashMapWatcher.html#a8eb19b22739aeb0b5c50a3e01a9285d0">00171</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> itPos;
<a name="l00172"></a><a class="code" href="classcConstHashMapWatcher.html#a7f45b1a46b5fd32164b9d7d12201df0d">00172</a>         std::string classname;
<a name="l00173"></a>00173     <span class="keyword">public</span>:
<a name="l00174"></a><a class="code" href="classcConstHashMapWatcher.html#acfd91e29cb60dc6b8bce329f23d16492">00174</a>         <a class="code" href="classcConstHashMapWatcher.html#acfd91e29cb60dc6b8bce329f23d16492">cConstHashMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;&amp; var) : cStdVectorWatcherBase(name), m(var) {
<a name="l00175"></a>00175             itPos=-1;
<a name="l00176"></a>00176             classname = std::string(<span class="stringliteral">&quot;unordered_map&lt;&quot;</span>)+opp_typename(<span class="keyword">typeid</span>(KeyT))+<span class="stringliteral">&quot;,&quot;</span>+opp_typename(<span class="keyword">typeid</span>(ValueT))+<span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l00177"></a>00177         }
<a name="l00178"></a><a class="code" href="classcConstHashMapWatcher.html#af9379caa92e9c41c17f04d1a69b9c431">00178</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcConstHashMapWatcher.html#af9379caa92e9c41c17f04d1a69b9c431">getClassName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> classname.c_str();}
<a name="l00179"></a><a class="code" href="classcConstHashMapWatcher.html#a34663832f56d9417dfe23bad2b031fc3">00179</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcConstHashMapWatcher.html#a34663832f56d9417dfe23bad2b031fc3">getElemTypeName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="stringliteral">&quot;struct pair&lt;*,*&gt;&quot;</span>;}
<a name="l00180"></a><a class="code" href="classcConstHashMapWatcher.html#aa07a772b3444add9fb059144ba9f7e71">00180</a>         <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcConstHashMapWatcher.html#aa07a772b3444add9fb059144ba9f7e71">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> m.size();}
<a name="l00181"></a><a class="code" href="classcConstHashMapWatcher.html#a2033599ff290a83f5a18cd557c8d4d00">00181</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcConstHashMapWatcher.html#a2033599ff290a83f5a18cd557c8d4d00">at</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l00182"></a>00182             <span class="keywordflow">if</span> (i==0) {
<a name="l00183"></a>00183                 it=m.begin(); itPos=0;
<a name="l00184"></a>00184             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==itPos+1 &amp;&amp; it!=m.end()) {
<a name="l00185"></a>00185                 ++it; ++itPos;
<a name="l00186"></a>00186             } <span class="keywordflow">else</span> {
<a name="l00187"></a>00187                 it=m.begin();
<a name="l00188"></a>00188                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i &amp;&amp; it!=m.end(); k++) ++it;
<a name="l00189"></a>00189                 itPos=i;
<a name="l00190"></a>00190             }
<a name="l00191"></a>00191             <span class="keywordflow">if</span> (it==m.end()) {
<a name="l00192"></a>00192                 <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;out of bounds&quot;</span>);
<a name="l00193"></a>00193             }
<a name="l00194"></a>00194             <span class="keywordflow">return</span> atIt();
<a name="l00195"></a>00195         }
<a name="l00196"></a><a class="code" href="classcConstHashMapWatcher.html#a1f0072e2cbe1c4555b33865ec1ec692b">00196</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcConstHashMapWatcher.html#a1f0072e2cbe1c4555b33865ec1ec692b">atIt</a>()<span class="keyword"> const </span>{
<a name="l00197"></a>00197             std::stringstream out;
<a name="l00198"></a>00198             out &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot; ==&gt; &quot;</span> &lt;&lt; it-&gt;second;
<a name="l00199"></a>00199             <span class="keywordflow">return</span> out.str();
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 };
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00204"></a><a class="code" href="hashWatch_8h.html#aa1d04d3a244fcda50eda323d4a0a790f">00204</a> <span class="keywordtype">void</span> <a class="code" href="hashWatch_8h.html#a31110eab64ba991374c69abcf8e17ba2">createHashMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *varname, <span class="keyword">const</span> UNORDERED_MAP&lt;KeyT,ValueT,CmpT&gt;&amp; m)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206     <span class="keyword">new</span> <a class="code" href="classcConstHashMapWatcher.html">cConstHashMapWatcher&lt;KeyT,ValueT,CmpT&gt;</a>(varname, m);
<a name="l00207"></a>00207 };
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00210"></a><a class="code" href="classcPointerMapWatcher.html">00210</a> <span class="keyword">class </span>SIM_API <a class="code" href="classcPointerMapWatcher.html">cPointerMapWatcher</a> : <span class="keyword">public</span> cStdVectorWatcherBase
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212     <span class="keyword">protected</span>:
<a name="l00213"></a><a class="code" href="classcPointerMapWatcher.html#abe69ff11fc4535103f803fdaecca86ea">00213</a>         std::map&lt;KeyT,ValueT,CmpT&gt;&amp; m;
<a name="l00214"></a><a class="code" href="classcPointerMapWatcher.html#ae39e67e158a8dee5c01d42d729d5a20a">00214</a>         <span class="keyword">mutable</span> <span class="keyword">typename</span> std::map&lt;KeyT,ValueT,CmpT&gt;::iterator it;
<a name="l00215"></a><a class="code" href="classcPointerMapWatcher.html#aedcabcc4cf9c22944721dc6cc70bf349">00215</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> itPos;
<a name="l00216"></a><a class="code" href="classcPointerMapWatcher.html#aebd9efcef83e3ac02585f8cd621e5263">00216</a>         std::string classname;
<a name="l00217"></a>00217     <span class="keyword">public</span>:
<a name="l00218"></a><a class="code" href="classcPointerMapWatcher.html#a39f836b5df27f9807a9056345ba5638d">00218</a>         <a class="code" href="classcPointerMapWatcher.html#a39f836b5df27f9807a9056345ba5638d">cPointerMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, std::map&lt;KeyT,ValueT,CmpT&gt;&amp; var) : cStdVectorWatcherBase(name), m(var) {
<a name="l00219"></a>00219             itPos=-1;
<a name="l00220"></a>00220             classname = std::string(<span class="stringliteral">&quot;pointer_map&lt;&quot;</span>)+opp_typename(<span class="keyword">typeid</span>(KeyT))+<span class="stringliteral">&quot;,&quot;</span>+opp_typename(<span class="keyword">typeid</span>(ValueT))+<span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l00221"></a>00221         }
<a name="l00222"></a><a class="code" href="classcPointerMapWatcher.html#a6b46b6dafa8cd2d2bb2201b8e52bad3d">00222</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcPointerMapWatcher.html#a6b46b6dafa8cd2d2bb2201b8e52bad3d">getClassName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> classname.c_str();}
<a name="l00223"></a><a class="code" href="classcPointerMapWatcher.html#a08d4615d858401c595d53f6fd405ac7a">00223</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcPointerMapWatcher.html#a08d4615d858401c595d53f6fd405ac7a">getElemTypeName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="stringliteral">&quot;struct pair&lt;*,*&gt;&quot;</span>;}
<a name="l00224"></a><a class="code" href="classcPointerMapWatcher.html#ab75bfb0e5e39e60db1c690be53f7063c">00224</a>         <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcPointerMapWatcher.html#ab75bfb0e5e39e60db1c690be53f7063c">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> m.size();}
<a name="l00225"></a><a class="code" href="classcPointerMapWatcher.html#a8ea4b2bf4155f3dfd7dfc116e440af38">00225</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcPointerMapWatcher.html#a8ea4b2bf4155f3dfd7dfc116e440af38">at</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l00226"></a>00226             <span class="keywordflow">if</span> (i==0) {
<a name="l00227"></a>00227                 it=m.begin(); itPos=0;
<a name="l00228"></a>00228             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==itPos+1 &amp;&amp; it!=m.end()) {
<a name="l00229"></a>00229                 ++it; ++itPos;
<a name="l00230"></a>00230             } <span class="keywordflow">else</span> {
<a name="l00231"></a>00231                 it=m.begin();
<a name="l00232"></a>00232                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i &amp;&amp; it!=m.end(); k++) ++it;
<a name="l00233"></a>00233                 itPos=i;
<a name="l00234"></a>00234             }
<a name="l00235"></a>00235             <span class="keywordflow">if</span> (it==m.end()) {
<a name="l00236"></a>00236                 <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;out of bounds&quot;</span>);
<a name="l00237"></a>00237             }
<a name="l00238"></a>00238             <span class="keywordflow">return</span> atIt();
<a name="l00239"></a>00239         }
<a name="l00240"></a><a class="code" href="classcPointerMapWatcher.html#afea2421377d788ac36a6a56bedc8af80">00240</a>         <span class="keyword">virtual</span> std::string <a class="code" href="classcPointerMapWatcher.html#afea2421377d788ac36a6a56bedc8af80">atIt</a>()<span class="keyword"> const </span>{
<a name="l00241"></a>00241             std::stringstream out;
<a name="l00242"></a>00242             out &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot; ==&gt; &quot;</span> &lt;&lt; *(it-&gt;second);
<a name="l00243"></a>00243             <span class="keywordflow">return</span> out.str();
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245 };
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00248"></a><a class="code" href="hashWatch_8h.html#a27d11f04337d291ba223a22b82d7bd5a">00248</a> <span class="keywordtype">void</span> <a class="code" href="hashWatch_8h.html#a27d11f04337d291ba223a22b82d7bd5a">createPointerMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *varname, std::map&lt;KeyT,ValueT,CmpT&gt;&amp; m)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250     <span class="keyword">new</span> <a class="code" href="classcPointerMapWatcher.html">cPointerMapWatcher&lt;KeyT,ValueT,CmpT&gt;</a>(varname, m);
<a name="l00251"></a>00251 };
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00254"></a><a class="code" href="classcStdMultiMapWatcher.html">00254</a> <span class="keyword">class </span><a class="code" href="classcStdMultiMapWatcher.html">cStdMultiMapWatcher</a> : <span class="keyword">public</span> cStdVectorWatcherBase
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256   <span class="keyword">protected</span>:
<a name="l00257"></a><a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">00257</a>     std::multimap&lt;KeyT,ValueT,CmpT&gt;&amp; <a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>;
<a name="l00258"></a><a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">00258</a>     <span class="keyword">mutable</span> <span class="keyword">typename</span> std::multimap&lt;KeyT,ValueT,CmpT&gt;::iterator <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>;
<a name="l00259"></a><a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">00259</a>     <span class="keyword">mutable</span> <span class="keywordtype">int</span> <a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">itPos</a>;
<a name="l00260"></a><a class="code" href="classcStdMultiMapWatcher.html#ab779d69551d7fcf4a9e40142983b232d">00260</a>     std::string <a class="code" href="classcStdMultiMapWatcher.html#ab779d69551d7fcf4a9e40142983b232d">classname</a>;
<a name="l00261"></a>00261   <span class="keyword">public</span>:
<a name="l00262"></a><a class="code" href="classcStdMultiMapWatcher.html#ae085e2928434c45703ff84fabf986f67">00262</a>     <a class="code" href="classcStdMultiMapWatcher.html#ae085e2928434c45703ff84fabf986f67">cStdMultiMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, std::multimap&lt;KeyT,ValueT,CmpT&gt;&amp; var) : cStdVectorWatcherBase(name), <a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>(var) {
<a name="l00263"></a>00263         <a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">itPos</a>=-1;
<a name="l00264"></a>00264         <a class="code" href="classcStdMultiMapWatcher.html#ab779d69551d7fcf4a9e40142983b232d">classname</a> = std::string(<span class="stringliteral">&quot;std::multimap&lt;&quot;</span>)+opp_typename(<span class="keyword">typeid</span>(KeyT))+<span class="stringliteral">&quot;,&quot;</span>+opp_typename(<span class="keyword">typeid</span>(ValueT))+<span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l00265"></a>00265     }
<a name="l00266"></a><a class="code" href="classcStdMultiMapWatcher.html#a10087db9be03739d080d60ff5dea2414">00266</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcStdMultiMapWatcher.html#a10087db9be03739d080d60ff5dea2414">getClassName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classcStdMultiMapWatcher.html#ab779d69551d7fcf4a9e40142983b232d">classname</a>.c_str();}
<a name="l00267"></a><a class="code" href="classcStdMultiMapWatcher.html#a47bdfd5791a59a1a2d6645782cdb1cdc">00267</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classcStdMultiMapWatcher.html#a47bdfd5791a59a1a2d6645782cdb1cdc">getElemTypeName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="stringliteral">&quot;struct pair&lt;*,*&gt;&quot;</span>;}
<a name="l00268"></a><a class="code" href="classcStdMultiMapWatcher.html#a24d10f8a569eec071544c23e25ece412">00268</a>     <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classcStdMultiMapWatcher.html#a24d10f8a569eec071544c23e25ece412">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>.size();}
<a name="l00269"></a><a class="code" href="classcStdMultiMapWatcher.html#a30245f677098ded703f5fa679d8f7eb0">00269</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classcStdMultiMapWatcher.html#a30245f677098ded703f5fa679d8f7eb0">at</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l00270"></a>00270         <span class="comment">// std::map doesn&#39;t support random access iterator and iteration is slow,</span>
<a name="l00271"></a>00271         <span class="comment">// so we have to use a trick, knowing that Tkenv will call this function with</span>
<a name="l00272"></a>00272         <span class="comment">// i=0, i=1, etc...</span>
<a name="l00273"></a>00273         <span class="keywordflow">if</span> (i==0) {
<a name="l00274"></a>00274             <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>=<a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>.begin(); <a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">itPos</a>=0;
<a name="l00275"></a>00275         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==<a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">itPos</a>+1 &amp;&amp; <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>!=<a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>.end()) {
<a name="l00276"></a>00276             ++<a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>; ++<a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">itPos</a>;
<a name="l00277"></a>00277         } <span class="keywordflow">else</span> {
<a name="l00278"></a>00278             <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>=<a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>.begin();
<a name="l00279"></a>00279             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i &amp;&amp; <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>!=<a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>.end(); k++) ++<a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>;
<a name="l00280"></a>00280             <a class="code" href="classcStdMultiMapWatcher.html#ad139a1c43f169dfa4889a9553d5cad62">itPos</a>=i;
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282         <span class="keywordflow">if</span> (<a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>==<a class="code" href="classcStdMultiMapWatcher.html#a2a093acbf0a4f53d761862fc75fc7ce0">m</a>.end()) {
<a name="l00283"></a>00283             <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;out of bounds&quot;</span>);
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285         <span class="keywordflow">return</span> <a class="code" href="classcStdMultiMapWatcher.html#a753b2225a5292c794a0895b4eec28221">atIt</a>();
<a name="l00286"></a>00286     }
<a name="l00287"></a><a class="code" href="classcStdMultiMapWatcher.html#a753b2225a5292c794a0895b4eec28221">00287</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classcStdMultiMapWatcher.html#a753b2225a5292c794a0895b4eec28221">atIt</a>()<span class="keyword"> const </span>{
<a name="l00288"></a>00288         std::stringstream out;
<a name="l00289"></a>00289         out &lt;&lt; <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>-&gt;first &lt;&lt; <span class="stringliteral">&quot; ==&gt; &quot;</span> &lt;&lt; <a class="code" href="classcStdMultiMapWatcher.html#afbbd91f921b2b5f5a1d185baede0f38f">it</a>-&gt;second;
<a name="l00290"></a>00290         <span class="keywordflow">return</span> out.str();
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292 };
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KeyT, <span class="keyword">class</span> ValueT, <span class="keyword">class</span> CmpT&gt;
<a name="l00295"></a><a class="code" href="hashWatch_8h.html#a9b125f8ca0ec5a3459f54d706aa6502c">00295</a> <span class="keywordtype">void</span> <a class="code" href="hashWatch_8h.html#a9b125f8ca0ec5a3459f54d706aa6502c">createStdMultiMapWatcher</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *varname, std::multimap&lt;KeyT,ValueT,CmpT&gt;&amp; m)
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297     <span class="keyword">new</span> <a class="code" href="classcStdMultiMapWatcher.html">cStdMultiMapWatcher&lt;KeyT,ValueT,CmpT&gt;</a>(varname, m);
<a name="l00298"></a>00298 };
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 
<a name="l00306"></a><a class="code" href="hashWatch_8h.html#a2e51703608bdb5d1f37f4ba7d96f72d0">00306</a> <span class="preprocessor">#define WATCH_UNORDERED_SET(variable)    createHashSetWatcher(#variable,(variable))</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00313"></a><a class="code" href="hashWatch_8h.html#a6c82de4985d07d27ae298e3defed5e6c">00313</a> <span class="preprocessor">#define WATCH_DEQUE(variable)    createDequeWatcher(#variable,(variable))</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>
<a name="l00320"></a><a class="code" href="hashWatch_8h.html#ae15520d5e275d3c6aef5da79fb633201">00320</a> <span class="preprocessor">#define WATCH_UNORDERED_MAP(m)           createHashMapWatcher(#m,(m))</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span>
<a name="l00327"></a><a class="code" href="hashWatch_8h.html#ae5678c8f482eb1afddaea5022e654865">00327</a> <span class="preprocessor">#define WATCH_POINTER_MAP(m)        createPointerMapWatcher(#m,(m))</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>
<a name="l00334"></a><a class="code" href="hashWatch_8h.html#ac3751704303addd5d8f0a36286e70780">00334</a> <span class="preprocessor">#define WATCH_MULTIMAP(m)         createStdMultiMapWatcher(#m,(m))</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span>
<a name="l00336"></a>00336 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 3 2010 14:40:44 for OverSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
